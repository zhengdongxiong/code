OSI七层模型：
    物理 数据链路 网络 运输 会话 表示 应用
    
    应用：文件传输，文件管理，电子邮件           HTTP、TFTP, FTP, NFS, WAIS、SMTP
    表示：确保一个系统的应用层发送消息被另一个系统应用层读取
            编码转换，数据解析，管理数据      Telnet, Rlogin, SNMP, Gopher
    会话：负责网络两节点建立，维持和终止通信    SMTP, DNS
    传输：定义传输数据的协议和端口，并进行流控制，根据接收方接收数据快慢，规定适当发送速率 TCP, UDP
    网络：控制子网的运行，逻辑编址，分组传输，路由选择最小单位--分组（包）    IP, ICMP, ARP, RARP, AKP, UUCP
    数据链路：对物理层比特流包装、检测保证数据传输的可靠性，将物理层接收的数据进行MAC地址的封装和解封装
    物理层：对物理连接制定一系列标准。
    
    
TCP/TP：
    应用 运输 网络IP 网络接口
    应用层:
    向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。
    远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。
    TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。

    传输层:
    提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。

    网络层 ：
    负责相邻计算机之间的通信。其功能包括三方面。
    一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。

    二、处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。

    三、处理路径、流控、拥塞等问题。

    网络接口层：1
    这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。
    
三次握手：
    1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认

    2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态
 
    3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。
    
    
    【问题3】为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

    现在把三次握手改成仅需要两次握手，死锁是可能发生的。
    作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认 应答分组。
    按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。
    可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。
    在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

四次挥手：
    由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，
    发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，
    但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

    （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

    （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

    （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

    （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
为什么需要四次挥手：

    答：前两次挥手是为了断开client至server的连接，后两次挥手是为了断开server至client的连接，如果没有第四次挥手，会出现如下状况：

    server发送FIN数据包并携带ACK至client之后直接断开连接，如果client没有收到这个FIN数据包，那么client会一直处于等待关闭状态，这是为了确保TCP协议是面向连接安全有保证锝。
    上面解释了为什么不是三次挥手，同理，两次挥手也是不安全的。不能保证server与client都能正确关闭连接释放资源，而不会造成资源浪费。

单播 组播（多播） 广播
    A类
        最高位为0，网段8位，主机位24位
        0.0.0.0 ~ 127.255.255.255       2^7-1 = 127
    B类
        最高位为10，网段16位，主机位16位
        128.0.0.0 ~ 191.255.255.255     2^7+2^6-1
    C类（常用局域网的地址）
        最高位为110，网段24位，主机位8位
        192.0.0.0 ~ 223.255.255.255     2^7+2^6+2^5-1
    D类
        剩下的都是组播地址
        224.0.0.0 ~ 255.255.255.255

frok()返回进程id

文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。
也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。

标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，
        具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。

    （1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 
    （2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 
    （3）不带缓存：stderr就是了。


1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，
    另一个进程要注意读写的问题，相当于线程中的线程安全，
    当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
6.信号：进程还可以发送信号给进程本身 
    
    进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
    
    内核
    栈
    堆(malloc calloc)
    数据段(.bss(未初始化/初始化为0全局变量和静态数据) .data(已初始化静态数据) .roadta(常亮))
    代码段(.text(用户代码) .init(系统初始化代码))
    不可访问段
    
    const 全局存放只读
Linux信号
    软中断信号（signal，又简称为信号）用来通知进程发生了异步事件
    
    可靠性方面：可靠信号与不可靠信号；
    与时间的关系上：实时信号与非实时信号。
    
pthread_join和pthread_detach
    一个可结合的线程能够被其他线程收回其资源和杀死。在被其他线程回收之前，它的存储器资源（例如栈）是不释放的
    一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。
    如果一个可结合线程结束运行但没有被join，则它的状态类似于进程中的Zombie Process，即还有一部分资源没有被回收，
    所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源。
    
    
    被释放的内存空间仅仅是系统空间，你必须手动清除程序分配的空间，比如 malloc() 分配的空间。
    一个线程只能被一个线程所连接。
    被连接的线程必须是非分离的，否则连接会出错。
    用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。
    对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，
    该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。


select
    可是使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，
    以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，
    它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。
    select系统调用是用来让我们的程序监视多个文件句柄的状态变化的。程序会停在select这里等待，直到被监视的文件句柄有一个或多个发⽣生了状态改变。
    select的优缺点 
优点： 
（1）select的可移植性好，在某些unix下不支持poll. 
（2）select对超时值提供了很好的精度，精确到微秒，而poll式毫秒。 
缺点： 
（1）单个进程可监视的fd数量被限制，默认是1024。 
（2）需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 
（3）对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。 
（4）select函数超时参数在返回时也是未定义的，考虑到可移植性，每次超时之后进入下一个select之前都要重新设置超时参数。

大端序：高位存低位
小端序：低位存低位

TCP
UDP
    端口0-1023系统 1024-65535操作系统分配
    1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
    2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保  证可靠交付
    3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;
        UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
    4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
    5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
    6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
ps命令查看
僵尸进程 
    即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。
    一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程
    在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，
    仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程需要它的父进程来为它收尸，
    如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。
    但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，
    
    SIGCHLD信号处理 wait函数处理 阻塞 waitpid
    
孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养
    但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，
    因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。
守护进程
    进程独立,不会随会话终端的结束而结束

怎么用数组表示链表
    静态链表
    struct
    {
        int Data;
        int cur;指向下一个位置 首位游标存第一个空的位置 数组最后一个游标存放第一个有数据位置 数据最后一个游标存放头下标
    }
memcpy
    内存拷贝函数 拷贝指定长度 void类型类型多
strcpy缺点
    char类型 '\0'停止 有内存越界

memcmp
    内存比较函数 比较前m个字节
strcmp
    只能比较字符串
内存泄漏

用户态/内核态
    用户态：处理机只能执行规定的指令，访问指定的寄存器和存储区，用户程序通常只能在这一级别执行
    内核态：可以访问所有的寄存器和存储区。
    用户态-->内核态
    系统调用    统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 read write frok
    异常
    外围设备中断

static
    局部变量：即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。
    全局变量：静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。
    函数：静态函数只能在声明它的文件中可见，其他文件不能引用该函数
malloc和new
    new/delete比malloc/free更加智能，其实底层也是执行的malloc/free
    new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。
    new编译器会根据类型信息自行计算 malloc要强制转换
C程序放进C++
    extern "C"{
    //C语言代码定义或声明。
    }
内核
一个字节对齐  
    #pragma pack (1)
        ....
    #pragma pack ()
数据类型
    char    --1     1
    short   --2     2
    int     --4     4
    long    --4     8
    float   --4     4
    double  --8     8
    
快排时间复杂度 nlogn   nlogn
插入  nn  n
冒泡  nn  n
堆排序 nlogn   nlogn
希尔
选择
归并
基数
    
树：
    二叉树
    完全二叉树   最后一行不满
    二叉搜索树 左边键值小于右边根结点处于左右之间ASL(平均查找次数) = (第i层*当层个数)/总
    平衡树 平衡因子《=1 LL右旋转 RR左旋 LR左右 RL右左
    哈夫曼树 两个数相加变成根 在与其余叶子结合结合
    哈夫曼编码 左0 右1 最优编码（叶子*查找次数）
    
    一面 基础C/C++ 数据结构 算法
    二面 逻辑思维
    
    内存基本构造
    大小端序 
    shell 查找一个文件存不存在    
    线程 进程
    malloc一次最大          理论上是进程空间的大小， 如32位机器为4GB的进程空间，  malloc最大值小于4G， 一般是2G左右吧。
    
    大顶堆
    哈希冲突
    统计单词中出现的次数
    字符串循环移动
    存放长方形 判断点是否在里面
    Linux启动顺序
    8桶 100个数据   1个个给我
    10个数字 1个选4个 确保4个