数据类型
    char        --1     1
    short       --2     2
    short int   --2     2
    int         --4     4
    long        --4     8
    long long   --8     8
    float       --4     4
    double      --8     8
    *           --4     8

=============================

const 作用 只读 防止修饰的东西被修改
const int * a; 修饰*a 表示指向内容不能修改
int * const a; 修饰a  表示指针不可以修改

=============================

static
static全局变量和普通全局变量的区别：static全局变量只初始化一次，这是为了防止它在其他文件单元中引用。
 
static局部变量和普通局部变量的区别：static局部变量只初始化一次，下次的运算依据是上一次的结果值。
 
static函数与普通函数的区别在与作用域不一样，static()函数只在一个源文件中有效，不能被其它源文件使用。

=============================

bool int float,指针变量与零作比较
if(flag)
if(a == 0)
if(if ((x >= - 0.00001) && (x <= 0.00001))
float是浮点数 存的是近似值
当用来表示0的时候
有可能计算结果是0，但是由于精度问题，实际上 存储的是一个和0很接近的值
而== 只要不是完全相等 就回是假
于是 用==判断float有可能出错。
一般都是判断差值的绝对值，低于某一个精度值，就可以认为是相等了。
if(a == NULL)

=============================

void *p = malloc(100);
sizeof(p) = 4;

=============================

结构类型或联合类型：
自身字节对齐值的大小是其成员中最大基本类型要求的有效字节对齐值

typedef union{ long i; double k; char c; } DATE;
struct data { int cat; DATE cow; double dog; } too;
DATE max;

sizeof(DATE) = 8; (最大字节共用) 取8字节 起始地址8的倍数
共用体在结构体里面起始地址为 最大字节倍数
sizeof(too) = 24; (int4 + 4(4+4满足起始地址为8倍数)  union8， double8) = 24(最大字节倍数)

typedef union{ long i; int k[5]; char c; } DATE;
struct data { int cat; DATE cow; double dog; } too;
sizeof(DATE) = 20; (最大字节共用) 取4字节 起始地址4的倍数

共用体在结构体里面起始地址为 最大字节倍数
sizeof(too) = 32; (int4   union20(起始位置为4倍数 union中最大为int4字节)， double8) = 32(最大字节倍数)


更改对齐方式
#pragma pack(2)  //指定按2字节对齐
struct C{
    char  b;
    int   a;
    short c;
};
#pragma pack()

=============================

void getmemory(char *p)
{
p=(char *) malloc(100);
strcpy(p,“hello world”);
}
int main( )
{
char *str=NULL;
getmemory(str);
printf(“%s/n”,str);
free(str);
return 0;
} 会出现什么问题？
【标准答案】程序崩溃，getmemory中的malloc 不能返回
动态内存，free （）对str操作很危险。
这段代码，一看有个特别明显的错误，就是GetMemory(str)这句，可
能有的人在存在疑问，str是指针啊，有什么错误?但是你看GetMemory(char* p)里面的参数，
两个都是char*类型，其实说的白话点，这种使用方式仅仅是值传递。

悬浮指针（未指向任何地址的指针或指向NULL的指针）不能作为参数传入函数，调用内存分配函数之后并不曾为p分配内存，而只是为a分配了内存。
getmemory(char *p); p函数里的这个参数只是p的一个副本，getmemory函数结束后就没了，malloc分配的内存首地址也没带出来，p还是原来的p没变，还发生了内存泄漏

void GetMemory2(char **p)变为二级指针
=============================

char* GetMen()
{
    char p[] = "hello";
    char *p = "hello";
    return p;
}

char p[]="hello world";中，"hello world"是一个字符串常量，存放在静态数据区；
但是把一个字符串常量赋值给了一个局部变量（char p[]型数组），该局部变量是存放在栈中的。
这样子就有两块内容一样的内存，意思就是说：char p[]="hello world";这条语句让"hello world"在内存中有两份拷贝，
一份在动态分布的栈中，一份在静态存储区，当函数GetString退出时，局部变量p的内存是要被清空的。
而第二个例子中变量str是指向静态存储区的指针，此变量指向的内存在程序运行过程中不会被清空。但不能修改。


=============================

5.数组和链表的区别？

不同：链表是链式的存储结构；数组是顺序的存储结构。

链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。

链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；

数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。
相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。

=============================

13、void main()
{
char aa[10];
printf(“%d”,strlen(aa));
}                                          
会出现什么问题？打印结果是是多少？
【标准答案】sizeof()和初不初始化，没有关系，
strlen()和初始化有关，打印结果值未知。

=============================

要对绝对地址0x100000赋值，我们可以用
*(unsigned int*)0x100000 = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行
，应该怎么做？
【标准答案】*((void (*)( ))0x100000 ) ( );
首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
然后再调用它:
*((void (*)())0x100000)();

=============================

嵌入式系统经常具有要求程序员去访问某特定的
内存位置的特点。在某工程中，要求设置一绝对地址
为0x67a9的整型变量的值为0xaa66。编译器是一个纯
粹的ANSI编译器。写代码去完成这一任务。
int * ptr;
ptr=  (int *)0x67a9;
*ptr = 0xaa55;

=============================

char *p ="hello world";     存储在.rodata中 程序结束在释放不能修改
    char p[] = "hello world";的区别
    char *p 代表指针p是一个指向字符常量的指针，指向一个常量区域，如果采用p[0] = 'H'等语句，就会报错。
    而 char p[]，中的p是一个被分配在一个可读可写内存中的字符数组的首地址，可以用p[0] = 'H'赋值。


=============================

volatile是一个类型修饰符（type specifier），就像我们熟悉的const一样，
它是被设计用来修饰被不同线程访问和修改的变量；volatile的作用是作为指令关键字，
确保本条指令不会因编译器的优化而省略，且要求每次直接读值。

1）并行设备的硬件寄存器（如：状态寄存器）

2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)

3）多线程应用中被几个任务共享的变量

int i = 5;

int a = i;

……

int b = i;

编译器发现两次从i读数据的代码之间，并没有对i进行过操作，它会自动把上次读的数据放在b中，而不是重新从i里面读取。

而volatile关键字告诉编译器该变量是随时可能发生变化的，每次使用它的时候必须从内存中取出它的值，因而编译器生成的汇编代码会从原内存地址中读取数据使用，
而不是从寄存器或者缓存中读取，从而保证了对特殊地址的稳定访问。

简言之，状态要经常变化的，为了防止我们编译优化而导致的存取的数据不同步的问题，这时我们就需要用到volatile。
不要把此类变量优化到寄存器中，每次都要老老实实的从内存中读取，因为它们随时都可能变化。
    
=============================

带参宏与带参函数的区别(至少说出5点)？
【标准答案】
                      带参宏                带参函数
处理时间             编译时                运行时
参数类型                 无                需定义
程序长度                变长                不变
占用存储空间           否                    是
运行时间           不占运行时间      调用和返回时占

=============================

程序的局部变量存在于___ 中，全局变量存在于
____中，动态申请数据存在于___ 中。
【标准答案】程序的局部变量存在于栈(stack) 中，全局
变量存在于静态数据区中，动态申请数据存在于堆（
heap）中。

=============================

什么是预编译，何时需要预编译：
【标准答案】１、总是使用不经常改动的大型代码体
。
２、程序由多个模块组成，所有模块都使用一组标准
的包含文件和相同的编译选项。在这种情况下，可以
将所有包含文件预编译为一个预编译头。

=============================

对于一个频繁使用的短小函数,在C 语言中应用什
么实现,在C++ 中应用什么实现?
【标准答案】c用宏定义，c++ 用inline

=============================

中断
中断服务子程序(ISR)
1)ISR 不能返回一个值（都应该为void类型）。如果你不懂这个，那么你不会被雇用的。
2)ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3)在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，
有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
 printf函数一般也是不可重入的，UART属于低速设备，printf函数同样面临大量消耗CPU时间的问题！
另外中断服务程序是运行在内核态的（linux），内核通常是不支持浮点运算的。

1、中断请求：中断事件一旦发生或者中断条件一旦构成，中断源提交“申请报告”，与请求CPU暂时放下目前的工作而转为中断源作为专项服务

2、中断屏蔽：虽然中断源提交了“申请报告”，但是，是否得到CPU的响应，
还要取决于“申请报告”是否能够通过2道或者3道“关卡”（中断屏蔽）送达CPU（相应的中断屏蔽位等于1，为关卡放行；
反之相应的中断屏蔽位等于0，为关卡禁止通行）；

3、中断响应：如果一路放行，则CPU响应中断后，将被打断的工作断点记录下来（把断点地址保护到堆栈），挂起“不再受理其他申请报告牌”（清除全局中断标志位GIE=0），跳转到中断服务子程序

4、保护现场：在处理新任务时可能破坏原有的工作现场，所以需要对工作现场和工作环境进行适当保护；

5、调查中断源：检查“申请报告”是由哪个中断源提交的，以便作出有针对性的服务；

6、中断处理：开始对查明的中断源进行有针对性的中断服务；

7、清除标志：在处理完毕相应的任务之后，需要进行撤消登记（清除中断标志），以避免造成重复响应；

8、恢复现场：恢复前面曾经被保护起来的工作现场，以便继续执行被中断的工作；

9、中断返回：将被打断的工作断点找回来（从堆栈中恢复断点地址），并摘下“不再受理其他申请报告牌”（GIE＝1），继续执行原先被打断的工作

=============================

宏和函数的优缺点？
 (1)、函数调用时，先求出实参表达式的值，然后带入形参。而使用带参数的宏只是进行简单的字符替换。
 (2)、函数调用是在程序运行时处理的，分配临时的内存单元；而宏展开则是在编译时进行的，在展开时并不分配内存单元，
   不进行值的传递处理，也没有“返回值”的概念。
 (3)、对函数中的实参和形参都要定义类型，二者的类型要求一致，应进行类型转换；而宏不存在类型问题，宏名无类型，
   它的参数也是无类型，只是一个符号代表，展开时带入指定的字符即可。宏定义时，字符串可以是任何类型的数据。
 (4)、调用函数只可得到一个返回值，而宏定义可以设法得到几个结果。
 (5)、使用宏次数多时，宏展开后源程序长，因为每次展开一次都使程序增长，而函数调用不使源程序变长。
 (6)、宏替换不占运行时间，只占编译时间；而函数调用则占运行时间（分配单元、保留现场、值传递、返回）。

=============================

char *strcpy(char *strDest, const char *strSrc)
 
{
 
if ( strDest == NULL || strSrc == NULL)
 
return NULL ;
 
if ( strDest == strSrc)
 
return strDest ;
 
char *tempptr = strDest ;
 
while( (*strDest++ = *strSrc++) != ‘\0’)
 
;
 
return tempptr ;
 
}

为了 实现链式表达 式。 例如        
int length = strlen( strcpy( strDest, “hello world”) );

=============================

实参出现在主调函数当中，当函数调用时，朱调函数把实参的值传送给被调函数的形参，从而实现函数间的数据传递。
传递方式有两种：值传递和地址传递方式。
当形参定义为变量时，实参可以是常量、变量和表达式，这种函数间的参数传递为值传递方式。值传递的特点是参数的“单向传递”；
数组元素又称为下标变量，它具有普通变量的一切性质，因此数组元素作为函数的实参进行数据传递是与普通变量没有任何区别，也是值传递
数组名是一个地址，是数组的首地址，因此用数组名作为函数的参数进行数据传递时，执行的是地址传递方式。
所谓地址传递，顾名思义实参传递的不是数据本身，而是数据存在的地址。函数调用时，把数组名即数组的首地址作为实参传递给形参（必须是可接受地址的数组名或者指针变量），
形参数组名取得首地址后就有了实在的数组，这时实质上实参和形参是同一个数组，指向同一段存储空间，实参的改变就是对形参的改变，所以传址方式可看成是数据进行了“双向传递”。
重点：
数组元素（下标变量）作为函数的参数进行的数据传递是值传递方式，数组名（数组首地址）、数组元素的地址（&arr[0]）作为函数参数进行的数据传递是地址传递方式。
实参为数组名是，形参接收时可以有三种形式：带下标的数组名(arr[0])。不带下标的数组名（arr）、可接收地址值的指针变量名（*a）。
由于是实参数组和形参数组都指向同一段内存单元，故它们操作的是同一批数据，所以形参的改变就是改变了实参中的数据。

=============================

int check_sys()
{
    int num = 1;
    char *p = (char *)&num;
    //&num为int *
    //我们只看第一个字节所以强转为char *

    if (*p == 1)
        return 0;//小端
    else
        return 1;//大端
}

int check_sys()
{
    union UN
    {
        char c;
        int i;
    }un;

    un.i = 1;
        if (un.c == 1)
            return 0;//小端
        else
            return 1;//大端
}

=============================

进程和线程的差别。
（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。
（3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
（4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
（6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

进程线程的区别：

地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
两者均可并发执行。
优缺点：

　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。

　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。

何时使用多进程，何时使用多线程？

对资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。   

=============================

堆和栈的区别

Heap是堆，stack是栈。
Stack的空间由操作系统自动分配/释放，Heap上的空
间手动分配/释放。
Stack空间有限，Heap是很大的自由存储区
C 中的malloc 函数分配的内存空间即在堆上,C++中对
应的是new 操作符。
程序在编译期对变量和函数分配内存都在栈上进行,且
程序运行过程中函数调用时参数的传递也在栈上进行。

（1）存储内容不同

栈：在函数调用时，栈中存放的是函数中（最底下是函数调用后的下一条指令）的各个参数（局部变量）。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员分配。

（2）管理方式上不同

栈：由系统自动分配并释放空间。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间，当对应的生存周期结束后栈空间被自动释放。

堆：需要程序员指定大小手动申请和手动释放，在C语言中使用malloc函数申请，使用free函数释放。

（3）空间大小不同

栈：获取空间较小。在Windows下一般大小是1M或2M，当剩余栈空间不足时，分配失败overflow。

堆：获得空间根据系统的有效虚拟内存有关，比较灵活、大。

（4）能否产生碎片不同

栈：不会产生碎片，空间连续。

堆：采用的是链表的存储方式，会产生碎片。

（5）生长方向不同

栈： 向低地址扩展的数据结构，是一块连续的内存区域。

堆： 向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表空闲内存地址来存储的，自然不连续，而链表的遍历方向是由低地址向高地址。

（6）分配方式不同

栈：有2种分配方式：静态分配和动态分配，静态由编译器完成，例如局部变量；动态由malloc函数实现，由编译器进行释放。

堆： 都是动态分配的，没有静态分配的堆。

（7）分配效率不同

栈：由系统自动分配，速度较快。但程序员无法控制。

堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

=============================

进程的同步机制

原子操作 信号量机制    自旋锁    管程，会合，分布式系统

进程的通信
无名管道：无名管道是一种半双工的通信方式，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子进程关系。

有名管道：有名管道也是一种半双工的方式，但是它允许无亲缘关系进程间的通信 。

信号量：信号量是一个计时器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，
其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步。

消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号：信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生f

共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但是多个进程都可以访问。
共享内存是最快的IPC方式，他是针对其他进程间通信方式运行效率低而专门设计的。他往往与其他通信机制，如信号量，配合使用，来实现进程间的通信与同步。

套接字：套接字也是一种进程间通信机制。

优缺点：无名管道简单方便，但局限于单向通信的工作方式，并且只能在亲缘进程之间通信，

有名管道虽然可以提供给任何关系的进程使用，但是由于其长期存在于系统之中，使用不当容易出错。

消息队列可以不局限于父子进程而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接受之间的同步，从而使得用户在使用消息缓冲进行通信不再需要考虑同步问题。
使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或者操作频繁的场合。

共享内存利用内存缓冲区直接交换信息，无需复制，快捷，信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的。
因此，进程之间的读写操作的同步问题操作系统无法自动实现，必须由各进程利用其它同步工具解决。

另外，由于内存实体存在于计算机系统中，所以只能由处于同一计算机系统中的诸进程共享，不能网络通信。

linux系统中多线程同步的方法有？

互斥锁、条件变量、信号量、读写锁

=============================

请简述用户空间的内存分配及各空间保存的数据类型

用户空间供为3G，分为：栈空间，堆空间，数据区，代码段
0xffffffff-0xc0000000内核地址空间

栈空间保存：局部变量，函数形参，自动变量。栈空间特点，先进后出，空间由系统管理；栈空间生命周期所在函数执行结束
后释放；栈空间保存的局部变量未初始化时，默认初始化为随机值。限度一般为8M

堆空间：由malloc , calloc ,ralloc，这些好函数分配的控件位堆空间，堆空间特点：先进先出，由用户管理

数据区：又分为.bss段、.data段、常量区。
    .bss段保存的是未初始化的全局变量，当全局变量未初始化时，系统默认初始化为0，
        BSS段属于静态内存分配。 
        BSS不包含任何数据,只是简单的维护开始和结束的地址,即总大小。
        以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,
        即占用磁盘空间而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。
    常量区保存的是常量(.rodata)，只读数据(常量)进程中所有的字符串、字符常量、整型浮点型常量
    .data段是保存已经初始化的全局变量以及被static修饰的
    变量(静态变量)。数据区的声明周期是整个程序执行完之后再释放。

代码段保存的是代码。
    .text 存放用户程序代码,包括main函数在内的所有用户自定义函数,
    .init 用来存储系统给每一个可以执行程序自动添加的初始化代码,包括环境比那里的准备,命令行参数的组织和传递
    
0x0-0x8048000未使用

=============================

嵌入式linux大致启动过程

1）设备上电后CPU启动

2）CPU启动bootloader,bootloader先初始化硬件

3）解压Image并拷贝到内存执行，

4）将内核区的镜像拷贝到内存解压，准备好内核的启动参数

5）内核启动，对各子系统和MMU完成初始化（MMU：cpu用来管理虚拟储存器，物理储存器的控制线路）其功能是把虚拟地址映射为物理地址。

6）内核挂载根文件系统

7）内核继续初始化其他驱动程序，第一个进程启动
    
=============================

中断与异常有何区别

    异常在处理的时候必须考虑与处理器的时钟同步，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，
    或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常；所谓中断是指外部硬件产生的一个电信号从CPU的中断引脚进入，
    打断CPU的运行。所谓异常是指软件运行过程中发生了一些必须作出处理的事件，CPU自动产生一个陷入来打断CPU的运行。

=============================

在ARM系统中，在函数调用的时候，参数是通过哪种方式传递的

当参数小于等于4的时候是通过r0-r3寄存器来进行传递的，当参数大于4的时候是通过压栈的方式进行传递。

=============================

总线接口    串/并 同步/异步   速率          工作方式    用线                  总线拓扑结构                  信距离
UART        串       异步      慢波特率设置  全双工     2线Rx、Tx             RS485支持总线式、星形、树形        远最远1200m

I2C         串       同步      慢               半双工     2线SDA、SCL               总线型（特殊的树形）          近

SPI         串       同步      快               全双工     3线或4线               环形                          远
                                                            SCLK、SIMO、SOMI、SS(片选)

USB         串       同步      快               半双工     4线                      星形                          近
                                                            Vbus（5V）、GND、D+、D-(3.3V)    

=============================

GDB调试
启动程序准备调试
GDB yourpram
或者
先输入GDB
然后输入 file yourpram
然后使用run或者r命令开始程序的执行,也可以使用 run parameter将参数传递给该程序

gcc -g -o e e.c
调试gdb e
或者输入gdb
然后 file e
run 
list l 显示多行源代码
break b 设置断点,程序运行到断点的位置会停下来 delete breakpoints 断点号
info i 描述程序的状态
run r 开始运行程序
display disp 跟踪查看某个变量,每次停下来都显示它的值
step s 执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next n 执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
watch  监视变量值的变化
continue c 继续程序的运行，知道遇到下一个断点。
set var i=8  设置变量的值
print p 打印内部变量值
quit q 退出GDB环境

=============================

C语言的编译过程：预处理、编译、汇编、连接
预处理  展开头文件/宏替换/去掉注释/条件编译  test.i main.i    -E
宏优点1代码复用性2提高性能
宏缺点1 不可调试（预编译阶段进行了替换），2无类型安全检查3可读性差，容易出错
编译     检查语法，生成汇编    test.s main.s   -S
汇编     汇编代码转换成机器码   test.o main.o -c
链接     链接到一起生成可执行文件    a.out -o
将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件

-ansi关闭gnu c中的ansi c不兼容的特性，激活ansi c的专有特性。
-share此选项将尽量使用动态库，所以生成文档比较小，但是需要系统有动态库。
-Wall(warning all)显示所有警告信息
-include file包含某个代码，相当于在代码中使用#include 
gcc hello.c -include /root/hello.h
-O0 -O1 -O2 -O3编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省，-O3优化级别最高

=============================

pthread_join和pthread_detach
    一个可结合的线程能够被其他线程收回其资源和杀死。在被其他线程回收之前，它的存储器资源（例如栈）是不释放的
    一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。
    如果一个可结合线程结束运行但没有被join，则它的状态类似于进程中的Zombie Process，即还有一部分资源没有被回收，
    所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源。
    
    
    被释放的内存空间仅仅是系统空间，你必须手动清除程序分配的空间，比如 malloc() 分配的空间。
    一个线程只能被一个线程所连接。
    被连接的线程必须是非分离的，否则连接会出错。
    用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。
    对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，
    该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。

=============================

僵尸进程 
    即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。
    一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程
    在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，
    仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程需要它的父进程来为它收尸，
    如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。
    但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，
    
    SIGCHLD信号处理 wait函数处理 阻塞 waitpid
    
孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养
    但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，
    因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。
守护进程
    进程独立,不会随会话终端的结束而结束

=============================

Linux内核的五大模块：进程调度模块、内存管理模块、文件系统模块、进程间通信模块、网络接口模块。

进程调度模块：用来负责控制进程对CPU 资源的使用。所采取的调度策略是各进程能够公平合理地访问CPU，同时保证内核能及时地执行硬件操作；
内存管理模块：用于确保所有进程能够安全地共享机器主内存区，同时，内存管理模块还支持虚拟内存管理方式，使得Linux 支持进程使用比实际内存空间更多的内存容量。
                并可以利用文件系统，对暂时不用的内存数据块交换到外部存储设备上去，当需要时再交换回来；
文件系统模块：用于支持对外部设备的驱动和存储。虚拟文件系统模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节。
                从而提供并支持与其它操作系统兼容的多种文件系统格式；
进程间通信模块：用于支持多种进程间的信息交换方式；
网络接口模块：提供对多种网络通信标准的访问并支持许多网络硬件。

=============================

*数据类型关键字（12）
char,short,int,long,float,double,unsigned,signed,union,enum,void,struct
*控制语句关键字（12）
if,else,switch,case,default,for,do,while,break,continue,goto,return
*存储类关键字（5）
auto,extern,register,static,const
*其他关键字（3）
sizeof,typedef,volatile

=============================

void checkCpuMode(void)
 {
  int a = 0x12345678;
  if((char)a == 0x12)
   printf("big endian\n");
  else 
   printf("little endian\n");
 }

=============================

物理地址，虚拟地址，逻辑地址和总线地址的区别
     逻辑地址（Logical Address）是指由程序产生的与段相关的偏移地址部分。
 例如，你在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，
 它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，
 逻辑地址才和物理地址相等（因为实模式没有分段或分页机制, Cpu不进行自动地址转换）；
 逻辑也就是在Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）。
 应用程序员仅需与逻辑地址打交道，而分段和分页机制对您来说是完全透明的，仅由系统编程人员涉及。
 应用程序员虽然自己可以直接操作内存，那也只能在操作系统给你分配的内存段操作。
     线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，
 或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，
 那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。
 Intel 80386的线性地址空间容量为4G（2的32次方即32根地址总线寻址）。
     物理地址（Physical Address） 是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。
 如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。
 如果没有启用分页机制，那么线性地址就直接成为物理地址了。
  在x86下，外设的i/o地址是独立的，即有专门的指令访问外设i/o，i/o地址就是你所说的“总线地址”。
 而“物理地址”就是ram地址。在arm中，i/o和ram统一编址，但linux为了统一各个平台，仍然保留这个概念，其实就是物理地址。  

=============================

STM32共有那几种基本时钟信号？

在STM32中，有五个时钟源，为HSI、HSE、LSI、LSE、PLL。
①、HSI是高速内部时钟，RC振荡器，频率为8MHz。
②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。
③、LSI是低速内部时钟，RC振荡器，频率为40kHz。
④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。
⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。

=============================

宏和函数的优缺点？
 (1)、函数调用时，先求出实参表达式的值，然后带入形参。而使用带参数的宏只是进行简单的字符替换。
 (2)、函数调用是在程序运行时处理的，分配临时的内存单元；而宏展开则是在编译时进行的，在展开时并不分配内存单元，
   不进行值的传递处理，也没有“返回值”的概念。
 (3)、对函数中的实参和形参都要定义类型，二者的类型要求一致，应进行类型转换；而宏不存在类型问题，宏名无类型，
   它的参数也是无类型，只是一个符号代表，展开时带入指定的字符即可。宏定义时，字符串可以是任何类型的数据。
 (4)、调用函数只可得到一个返回值，而宏定义可以设法得到几个结果。
 (5)、使用宏次数多时，宏展开后源程序长，因为每次展开一次都使程序增长，而函数调用不使源程序变长。
 (6)、宏替换不占运行时间，只占编译时间；而函数调用则占运行时间（分配单元、保留现场、值传递、返回）。

=============================

开发板芯片 s5p6818-- cortex-A53

=============================

//定义一个引脚配置的结构体
//配置相应组时钟
GPIO_InitStruct.GPIO_Pin    = GPIO_Pin_9|GPIO_Pin_10;       //指定9号引脚
GPIO_InitStruct.GPIO_Mode   = GPIO_Mode_OUT;    //输出功能
GPIO_InitStruct.GPIO_Speed  = GPIO_Speed_50MHz; //50M速度
GPIO_InitStruct.GPIO_OType  = GPIO_OType_PP;    //推挽输出，增大输出能力
GPIO_InitStruct.GPIO_PuPd   = GPIO_PuPd_UP;     //上拉
//初始化

开启关闭灯 

=============================

配置系统定时器(已经8分频)
SysTick->LOAD = 21*nus; //微秒数 不能超过 798915微秒         //时间加载
SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; //使能系统定时器     //使能定时器
while(((SysTick->CTRL & (1<<16)) == 0) && (SysTick->CTRL & 0x01));//延时开始
SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; //关闭系统定时器

=============================
1、确定外部EXTI0 中断线接那个引脚
2、把引脚配置输入模式
3、把引脚连接到中断线
4、配置中断线 
5、配置配置中断
6、编写中断服务函数
中断
//中断分组 -- 设置一次就可以了
/* Enable SYSCFG clock 使能系统配置时钟*/
GPIO配置结构体
外部中断线配置结构体
中断配置结构体
//按键中断配置 
//开启PA0的引脚时钟
//1 配置PA0 为输入模式
//2 把引脚连接到中断线

//3配置外部中断线
EXTI_InitStruct.EXTI_Line    = EXTI_Line0; //中断线0
EXTI_InitStruct.EXTI_Mode    = EXTI_Mode_Interrupt; //中断模式
EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising; //上升沿
EXTI_InitStruct.EXTI_LineCmd = ENABLE;              //使能
EXTI_Init(&EXTI_InitStruct);


//4配置EXIT0中断
NVIC_InitStruct.NVIC_IRQChannel                   = EXTI0_IRQn; 
NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0x0F;
NVIC_InitStruct.NVIC_IRQChannelSubPriority        = 0x0F;
NVIC_InitStruct.NVIC_IRQChannelCmd                = ENABLE;
NVIC_Init(&NVIC_InitStruct);

编写中断服务函数
//5中断服务函数编写
//参数 返回值为void
检查中断标志位
//最后清空标志位
void EXTI0_IRQHandler(void)   
{
    //检查是否为当前的外部中断线 EXTI0_Line 触发中断  需要调用函数检查
    if(EXTI_GetITStatus(EXTI_Line0) == 1)
    {
        //改变流水灯的方向
        //GPIO_ToggleBits(GPIOF, GPIO_Pin_10);
        PEO(14) = 0;
        //清空中断标志位
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}

=============================

1、使能定时器的时钟          （找到该外设对应的时钟初始化函数）
                
2、定时器初始化结构体配置   （TIM_TimeBaseInitTypeDef）
    预分频值：   APB2总线时钟 168M -- TIM1 --- 168M      减一   1680 - 1 
    计数值 ：   参考系统定时器计算                       减一   1000 - 1               
    二次分频：   #define TIM_CKD_DIV1                       
                #define TIM_CKD_DIV2                      
                #define TIM_CKD_DIV4  
TIM_TimeBaseInitStruct.TIM_Prescaler     = 16800 - 1;           // 168000000/1680  10000  
TIM_TimeBaseInitStruct.TIM_Period        = nms*10 - 1;          //一毫秒为单位
TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;        // 1 分频
TIM_TimeBaseInitStruct.TIM_CounterMode   = TIM_CounterMode_Up;  // 向上计数模式               
                        
3、调用函数来初始化          （TIM_TimeBaseInit）

4、配置定时器中断           （NVIC_InitTypeDef）-- stm32f4xx_msic.h 

5、调用函数初始化判断     （NVIC_Init）     -- stm32f4xx_msic.c 

6、开启定时器中断           （TIM_ITConfig）

7、使能定时器             （TIM_Cmd）

编写中断服务函数

=============================

单工：是指数据传输仅能沿一个方向，不能实现反向传输。
半双工：是指数据传输可以沿两个方向，但需要分时进行传输。
全双工：是指数据可以同时进行双向传输。

1.并行通信和串行通信
（1）并行通信
并行通信是同时传送数据的各个位进行发送or接收的通信方式。
传输率比串行接口快8倍，理论值为1Mbits/s.
传输的信息不要求固定格式
通信抗干扰能力插
传输距离小于30m

（2）串行通信
串行通信是常用的通信协议，其会将数据按位一次传输。
线路简单、成本较低
传输速度比并行通信慢。
RS-232一般通信距离较近时使用（<12m）,最大速度为20Kbits/s。
RS-422/485通信距离与速率成反比，理论最大距离为1.2KM，最大速度为10Mbits/s。
422最多可以接10个节点，485最多可以接32个节点。


同步通信是指发送端和接收端必须使用同一时钟，是一种连续传送数据的通信方式，一次通讯传送多个字符数据（一帧数据）。
同步串行通信方式：把许多字符组成一个信息组（信息振），每帧的开始用字符来指示。并且发送和接收的双方必须采用同一时钟，这样接收方就可以通过时钟信号来确定每个信息位。（如下图所示）
同步串行通信帧：是将许多字符组成一个信息帧，字符可以一个接一个传输。但是，需要在每帧信息的开始加上同步字符，在没有信息要传输时，要填上空字符，因为同步传输不允许有间隙。
同步串行通信的特点：必须有同步时钟，传输信息量大，传输速率高，但是传输设备则为复杂，技术要求高。

异步通信是指发送和接收端使用的是各自的时钟，并且它是一种不连续的传输通信方式，一次通信只能传输一个字符数据（字符帧）。字符帧之间的间隙可以是任意的，在STM32中USART就是使用的是异步通信方式
异步串行通信方式：是指通信双方以一个自读（包括特定附加位）作为数据传输单位且发送方传送字符的间隔时间是不定的，具有不规则数据段传输特性
异步串行同信帧：将一个字节数据加上起始位、校验位以及停止位构成字符帧。由于异步通信没有同步时钟，所以接收端要时刻处于接收状态。
起始位：在没有数据传送时（空闲状态），此时通信线上为逻辑“1”。当发送端要发送一个数据时，首先发送一个逻辑“0”，这个低电平就是帧格式的起始位。作用是告诉接收端要开始发送一帧数据。接收端检测到这个低电平之后，就准备接收数据信号。
数据位：在起始位之后，发送端发出的就是数据位，数据位的位数没有严格限制（5-8位都可以）。低位在前，高位在后。由低位向高位逐位发送。
校验位：数据位发送完成之后，可以发送以为用来校验数据在传送过程中是否出错。校验位是收发双方预先约定好的有限制差错检验的方式之一（可不用）。
停止位：字符帧格式的最后部分是停止位，逻辑“1”有效，它的占位有1/2位、1位或者2位。停止位表示传送一帧信息的结束，也作为发送下一帧数据信息做准备。
异步串行通信特点：不需要同步时钟，通信实现简单，设备简单。但是传输速率不高。

全双工：通信双方可以同时发送和接受信息
半双工：任意时刻，数据只能单向传输

异步：在传输时，没有时钟规定发送频率，要实现通过比特率形式来约定传输速度
同步：在传输时，发送端有一个时钟，按照该时钟的频率进行发送

并行：有多个数据线同时传输数据
串行：只要1根数据线传输数据
    由于要传输速度过快时，并行通信的导线会产生电磁效应，影响数据的准确性
所以并行通信存在速度上限(速度上限与导线之间的距离相关)
    所以10Mb以上的，都是串行通信：CAN总线，SPI总线

=============================

使能时钟
//配置GPIOF 9 号  //配置串口引脚  PA9  PA10
GPIO_InitStruct.GPIO_Pin    = GPIO_Pin_9;       //指定9号引脚
GPIO_InitStruct.GPIO_Mode   = GPIO_Mode_AF;     //复用
GPIO_InitStruct.GPIO_Speed  = GPIO_Speed_50MHz; //50M速度
GPIO_InitStruct.GPIO_OType  = GPIO_OType_PP;    //推挽输出，增大输出能力
GPIO_InitStruct.GPIO_PuPd   = GPIO_PuPd_UP;     //上拉

//把引脚绑定到AF -- USART
//开启usart1时钟

//配置usart参数
USART_InitStruct.USART_BaudRate = boaud;        //设置波特率
USART_InitStruct.USART_WordLength = USART_WordLength_8b;    //数据位
USART_InitStruct.USART_StopBits = USART_StopBits_1;     //停止位
USART_InitStruct.USART_Parity = USART_Parity_No;    //校验位
USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;    //流控制
USART_InitStruct.USART_Mode = USART_Mode_Tx;    //模式

//使能串口时钟
USART_Cmd(USART1, ENABLE);

//中断配置 中断触发收消息

//发送字符串
void usart1_send_str(char *str, int len)
{
    uint8_t i = 0;
    while(i < len)
    {
        USART_SendData(USART1, str[i++]);
        //等待1个字符发送完毕
        while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    }
}

=============================

1、配置PA5为模拟输入模式  
2、ADC初始化 ADC_CommonInitTypeDef
3、ADC初始化 ADC_InitTypeDef
4、指定ADC常规通道采样
5、使能ADC
6、启动装换
7、等待转换结束
8、获取装换值
9、计算电压值

ADC_CommonInitStruct.ADC_Mode = ADC_Mode_Independent;       //独立转换
ADC_CommonInitStruct.ADC_Prescaler = ADC_Prescaler_Div4;    //时钟 84/2 42M
ADC_CommonInitStruct.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;    //禁止DMA
//ADC_CommonInitStruct.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; //5周期个延迟 -- 在使用多个ADC是需要配置
ADC_CommonInit(&ADC_CommonInitStruct);


ADC_InitStruct.ADC_Resolution = ADC_Resolution_12b; //12位精度
ADC_InitStruct.ADC_ScanConvMode = DISABLE;     //禁止自动扫描
ADC_InitStruct.ADC_ContinuousConvMode = ENABLE ;   //连续装换
ADC_InitStruct.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; //禁止触发
ADC_InitStruct.ADC_DataAlign        = ADC_DataAlign_Right; //数据右对齐
ADC_InitStruct.ADC_NbrOfConversion  = 1;               //执行一次转换

//指定ADC通道，采样周期
    ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_3Cycles);

=============================

7位I2C总线可以挂接127个不同地址的I2C设备 最后一位读写位

1、发起开始信号 （先把SDA 拉低，scl拉低，接收方）
2、发送设备地址,寻址  --- 应答
3、发送数据地址        --- 应答
4、发送数据              --- 应答
5、停止

iic数据线时钟线引脚配置   SCL低时 SDA才能改变
//空闲状态
SCL = 1;
SDA_W = 1;

数据线的方向  需要随时改变

起始信号        在SCL为高SDA高，SDA由高跳变到低时开始信号   SCL变低
停止信号        开始SCL低SDA低 在SCL为高电平时，SDA由低跳变到高时开始信号

发送字节    数据线输出 SCL低  改变数据 SCL高时  SCL低
接收字节    数据线输入 SCL低 SCL高 读取数据 SCL低

主机每发生一个字节数据     SCL为低 SDA设置为输入为低是应答信号，为高则是非应答信号。SCL拉高 SCL拉低
等待应答 SCL高 判断SDA线  低时应答（高为非应答结束） SCL拉低

=============================

SPI
CPOL（时钟极性）和CPHA（时钟相位）
Mode0：CPOL=0，CPHA=0
Mode1：CPOL=0，CPHA=1
Mode2：CPOL=1，CPHA=0
Mode3：CPOL=1，CPHA=1
CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时
CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时
CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿
CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿

CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是
SCLK由低电平到高电平的跳变，所以数据采样是在上升沿，数据发送是在下降沿。

CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是
SCLK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。

CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是
SCLK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。

CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是
SCLK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。


=============================

void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
int munmap(void* start,size_t length);

start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。
length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理
prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起
    PROT_EXEC //页内容可以被执行
    PROT_READ //页内容可以被读取
    PROT_WRITE //页可以被写入
    PROT_NONE //页不可访问
flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体
    MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
    MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
    MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
    MAP_DENYWRITE //这个标志被忽略。
    MAP_EXECUTABLE //同上
    MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
    MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
    MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。
    MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
    MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
    MAP_FILE //兼容标志，被忽略。
    MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
    MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
    MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。
fd：有效的文件描述词。一般是由open()函数返回，其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。
off_toffset：被映射对象内容的起点。

=============================
电子相册
    搜索目录下的图片并将图片存放到链表中,然后开始播放,用户可以选择播放模式 自动循环播放/手动滑动播放(图片切换不同效果)
创建链表
搜索目录下所有图片
    打开指定目录
    获取路径
    搜索bmp图片
    插入链表中
展示图片
    触屏
        struct input_event
        //不停获取xy值
        if(coordinate.type == EV_ABS)
        {
            if(coordinate.code == ABS_X)
                x = coordinate.value;
            if(coordinate.code == ABS_Y)
                y = coordinate.value;
        }
        
        滑动
            coordinate.type == EV_KEY
            coordinate.code == 0x14a
            coordinate.value == 1
                保存一个初始xy值
            coordinate.value == 0
                退出计算滑动怎么滑动
            if(y-y1 > 150 || y-y1 < -150)
                return 0;
            else if(x-x1 > 20)//向右滑
                return 1;
            else if(x-x1 < 20)//向左滑
                return -1;
        点触
            coordinate.value == 0
            判断按的位置
        
    展示一张图片
        打开屏幕驱动
        打开图片
        图片头字节偏移lseek
        读取像素点bmp(bgr)
        转移到int型(argb)
            bmp[i*3]<<0 | bmp[i*3+1]<<8 | bmp[i*3+2]<<16;
        映射到lcd上(mmap)
            mmap(NULL,800*480*4,PROT_READ|PROT_WRITE,MAP_SHARED,fd_lcd,0);
        改变图片存储方向bmp为下-》上 lcd上-》下
            *(lcd_mmap+800*(479-y)+x)=lcd[800*y+x];
        释放映射内存
    切换图片触屏设置
释放链表

=============================
烟雾报警器
    烟雾火焰温度通过ADC转换，在经过DMA直接存储到指定数据存放位置中，经过stm32时刻监视着环境，一旦发生异常发出警报。
    用户可以利用预先设计的命令触发中断发送至wifi模块，经过串口存储到特定的位置中并且识别用户命令，然后在经过wifi模块发送回指定用户手机上，若命令错误则返回正确命令的列表。
NVIC分组
时钟分频
Led配置
蜂鸣器配置
串口配置
    if(Send_Status)
    {
        //下面开始接收手机发送的消息
        Recv_Data[loop] = USART_ReceiveData(USART2);
        
        //接收完成
        if(Recv_Data[loop] == '$')
        {
            //接收完成清空接收数据
            memset(Recv_Data, 0, MAXSIZE);
            
            //代表接收完成主程序可以运行
            Recv_Status = ENABLE;
            
            //手机端数据发送完成
            Send_Status = DISABLE;
            
            loop = 0;
        }
        else
        {
            //清空接收缓存区
            if(loop == 0)
                memset(ESP_Data, 0, MAXSIZE);
            
            ESP_Data[loop] = Recv_Data[loop];
            
            loop++;
            //防止越界
            if(loop > MAXSIZE)
                loop = 0;
        }
    }
    else
    {
        Recv_Data[loop] = USART_ReceiveData(USART2);
        switch(Recv_Data[loop])
        {
            //开始发送
            case '$':
                Send_Status = ENABLE;
                break;
            
            //用户发送数据标志 +IPD,连接号码,......
            case '+':
                Client_Status = ENABLE;
                break;
        }
    }
ESP初始化
    重启模块    
        "AT+RST\r\n"
    设置模式 设置CWMODE   STA模式   
        "AT+CWMODE=1\r\n"
    设置启动wifi 名字为MyWifi 密码12345678 加入wifi测试
        "AT+CWJAP=\"MEIZU\",\"12345678\"\r\n"
    开启多路连接
        "AT+CIPMUX=1\r\n"
    创建服务器 端口23333
        "AT+CIPSERVER=1,23333\r\n"
    设置超时
        "AT+CIPSTO=2880\r\n"
    查看本模块所接入的ip地址
        "AT+CIFSR\r\n"
开启温湿度模块器
ADC(DMA)配置
    双ADC    烟雾 火焰
    双ADC配置
        开启ADC12时钟
        双ADC工作模式同时
        四分频 变为21M 不超过36M
        ADC_DMAAccessMode_2 DMA模式见中文参考手册
        采用周期延迟
         
         
        12位精度
        禁止自动扫描（单通道）
        连续装换
        禁止触发
        数据右对齐
        单通道
        
        初始化ADC1
        开始通道采集(规定多通道顺序)
        初始化ADC2
        开始通道采集
        
        使能DMA请求
        开启DMA使能
        开启ADC1使能
        开启ADC2使能
        开始 adc 转换
    DMA配置
        开启DMA时钟
        配置ADC转换后存数据地点
        配置外设-->内存
        从外设直接到内存
        一次转换一个数据
        只有一个寄存器地址不递增
        存储器地址固定
        外设数据大小为32位4字节
        存储器数据大小一样
        循环
        设置通道优先级
        ADC1在通道0
        使能 DMA 流
while(1)
{
    检测警报
    判断温度大于60
        报警
    判断火焰距离小于30
        报警
    判断是否有用户命令
        检测命令
            strncmp对比设置好的命令
        stm32发送回用户手机
            sprintf(buf, "AT+CIPSEND=%c,8\r\n", Client_Number);
            USART2_STR(buf,strlen(buf));
            Delay_ms(100);
            memset(buf, 0, 32);
            sprintf(buf, "No Fire\n");
            USART2_STR(buf,8);
}

=============================

