
内存寻址
	MMU(内存控制单元)
		逻辑地址: 机器指令中指定一个操作数或一条指令的地址, 组成: 段选择符(16bit) + 偏移量(32bit)
		逻辑地址 --分段单元--> 线性地址 --分页单元--> 物理地址
		段选择符 ----> 描述符表(查找) --> +偏移量 = 虚拟地址
	内存仲裁器
		多个CPU共享内存, RAM芯片由独立CPU并发访问, RAM空闲准许一个CPU访问
	分段
		cs, ss, ds, es, fs, gs六个段寄存器, 存放段选择符
		cs: 代码段寄存器, 指向包含程序指令的段, 包含特权级0~3, 0内核态, 3用户态
		ss: 栈寄存器, 指向包含当前程序栈的段
		ds: 数据段, 指向包含静态数据或者全局数据段

		段选择符
			通常包含三个字段
				index: 放在GDT/LDT中的对应偏移(13bit)
				TI: 0代表在GDT中, 1代表在LDT中(1bit)
				RPL: 相应段放入CS中时, 指示CPU当前的特权级(2bit)
			GDT/LDT内段描述符 = 段选择符13bit*8
			GDT地址 = 0x00020000(保存在gdtr寄存器中)
			段选择符索引号 = 2
			段描述符所在地址 = 0x00020000 + (2 << 3) = 0x00020010
			GDT中第一项总是0, GDT存放段描述符最大数目为2^13 - 1 = 8191
		段描述符
			每一个段由8字节段描述符表示, 描述段特征, 放在全局描述符表(GDT)/局部描述符表(LDT)中
			通常定义一个GDT, 每个进程存放GDT段之外, 若有需要创建LDT, 
			GDT: GDT在主存的地址和大小放在gdtr控制寄存器中
			LDT: 当前正在被使用的LDT地址和大小放在ldtr控制寄存器中
			代码段描述符(64bit, 每一位均有含义)
				代表一个代码段, S标志为1
			数据段描述符(64bit, 每一位均有含义)
				代表一个数据段, 可以放在GDT或LDT中, S标志为1, 
			任务状态段描述符(64bit, 每一位均有含义)
				代表一个任务状态段, 段用于保护处理器寄存器的内容, 出现在GDT中, S标志为0
			局部描述符
				包含一个LDT段, 只出现在GDT中

		快速访问段描述符
			非编程的寄存器, 供6个可编程段寄存器使用
			 段选择符放入段寄存器中, 相应段描述符由内存装入对应的非编程寄存器中,
			针对那个段的逻辑地址转换, 可以不访问主存中GDT/LDT, 直接引用非编程寄存器, 
			当段寄存器内容改变时, 才有必要访问GDT/LDT

		分段单元
			1.检查段选择符TI字段, 决定段描述符保存在哪一个描述符表中, 从gdtr/ldtr获取基地址
			2.计算index得到段描述符, 将偏移量 + 段描述符Base字段 = 线性地址

		Linux中的分段
			只有在2.6版80x86架构下才使用分段
				1.当所有进程使用相同段寄存器时, 内存管理简单, 共享同一组线性地址
			第二章Linux中的分段

	分页
		页
			  线性地址分为固定长度单位的组, 页内部线性地址映射到连续的物理内存中,可以指定
			可以指定一个页的物理地址与存取权限, 而不用指定页所包含的全部线性地址的存取权限
			页指一组线性地址, 又指包含在这组地址中的数据
		页框
			  将所有RAM分成固定长度的页框(或者叫物理页), 每一个页框包含一个页,
			页框是主存的一部分, 页是一个数据块, 可以放在任何页框或者磁盘中
		页表
			线性地址映射到物理的数据结构, 存在主存中, 启用分页单元之前, 由内核对页表初始化
		分页单元
			访问类型与线性地址的访问权限比较, 若内存访问无效产生缺页异常, 处理4KB页
		常规分页
			页大小4KB
			32线性地址划分
				dir(页目录10bit) + table(页表10bit) + offset(12bit)
			使用一级页表: 2^20个页表项(高20bit都可以检索页表), 一个4B, 共占用4MB内存空间
			为每个活动进程分配页目录, 但实际需要一个页表时才给页表分配RAM
			CR3寄存器: 正在使用的页目录的物理地址
			页表基地址 = 页目录项 = CR3 + 页目录
			页表项 = 页表基地址 + 页表
			物理地址 = 页表项 + offset
			页目录/页表项包含字段
				高20字段
					每一个页框4KB容量, 物理地址必须2^12倍数, 因此低12位全为0
					字段指向一个页目录,则相应页框就有一个页表
					指向一个页表,则相应页框就有页数据
				低12位
					P: 为1表示页表或者页位于内存中, 否则, 表示不在内存中, 将线性地址放入CR2寄存器中, 产生14号中断, 必须先予以创建或者从磁盘调入内存后方可使用
					R/W: 读写标志。为1表示页面可以被读写, 为0表示只读。当处理器运行在0、1、2特权级时, 此位不起作用。页目录中的这个位对其所映射的所有页面起作用
					U/S: 用户/超级用户标志。为1时, 允许所有特权级别的程序访问；为0时, 仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用
					PWT: Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉）, 此标志被忽略。对于我们的实验, 此位清零
					PCD: Page级的Cache Disable标志位。为1时, 物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时, 此标志被忽略。对于我们的实验, 此位清零
					A: 访问位。该位由处理器固件设置, 用来指示此表项所指向的页是否已被访问（读或写）, 一旦置位, 处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率
					D: 脏位。该位由处理器固件设置, 用来指示此表项所指向的页是否写过数据
					PS: Page Size位。为0时, 页的大小是4KB；为1时, 页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled)
					G: 全局位。如果页是全局的, 那么它将在高速缓存中一直保存。当CR4.PGE=1时, 可以设置此位为1, 指示Page是全局Page, 在CR3被更新时, TLB内的全局Page不会被刷新
					AVL[11]: 被处理器忽略, 软件可以使用
		扩展分页
			允许页大小为4MB
			32线性地址划分
				dir(页目录10bit) + offset(22bit)
			通过设置CR4寄存器的PSE标志使扩展分页与常规内存分页共存
		例子
			已经分配给进程空间0x20000000~0x2003ffff, 64页
			dir = 0x80 --> 页目录第129项含有页表基地址
			table = 0x~0x03f --> 页表项中前64个有意义
			读取线性地址0x20021406中数据
				dir = 0x80 --> 选择页目录第0x80项查找页表
				table = 0x21 --> 选择页表中第0x21表项查找物理地址
				offset = 0x406 --> 读取物理地址偏移0x406中字节
				如果table中present标志位0, 产生缺页异常, 进程访问范围外地址, 均产生缺页异常
		物理地址扩展分页
			32位线性地址转换为36位物理地址可寻址2^36 = 64GB
			通过设置CR4中PAE标志激活PAE, 页目录项中的大小标志改为2MB
			引入页目录指针表(PDPT), 由4个64位表项组成
			CR3包含一个27位页目录指针表基地址, PDPT存放在RAM中前4GB中, 并在32bytes倍数对齐
			映射到4KB时
				CR3 指向PDPT
				pdpt表项(2bit) + dir(页表9bit) + table (9bit)+ offset(12bit)
			映射到2MB时
				CR3 指向PDPT
				pdpt表4项中的一个2bit) + dir(页表8bit) + offset(21bit)
		硬件高速缓存
			73页(cache)
		TLB
			  线性地址第一次被使用时, 通过慢速访问RAM中页表计算出相应的物理地址,
			同时物理地址存放在TLB表项中, 以便以后对同一个线性地址引用可快速转换
			  每一个CPU上都有TLB表, 当CPU的CR3寄存器被修改时, 硬件使本地TLB所有项无效

	Linux中的分页
		采用4级分页(兼容32和64bit系统)
			PGD + PUD + PMD + PT + offset
			对于两级页表足够系统(32bit), 页上级目录(PUD)和页中间目录(PMD)均为0
		  每一个进程有自己的页全局目录, 发生进程切换时, 把CR3寄存器的内容保存执行进程的描述符中
		将下一个要执行的进程描述符装入CR3中
		线性地址字段
			PAGE_SHIFT
				值为12, 指定offset位数, 页大小4KB, PAGE_MASK(0xfffff000)屏蔽offset所有位
			PMD_SHIFT
				offset与table字段总位数
				PAE禁用时, 值为22(offset 12bit + table 10bit)
				PAE激活时, 值为21(offset 12bit + table 9bit)
			PUD_SHIFT
				32位中等价于PMD_SHIFT
			PGDIR_SHIFT
				PAE禁用时, 值为22(offset 12bit + table 10bit, 同PMD_SHIFT)
				PAE激活时, 值为30(offset 12bit + table 9bit + PMD 9bit)
			PTRS_PER_PTE/PME/PUD/PGD
				计算页表/页中间目录/页上级目录/页全局目录中表项个数
				PAE禁用时, 值分别为1024, 1, 1, 1024
				PAE激活时, 值分别为512, 512, 1, 4
		页表处理
			PAE激活时, 下列数据类型均为64位, 否则32位
			pte/pmd/pud/pgd/pgprot_t
				页表项, 页中间目录项, 页上级目录项, 页全局目录项, 单独表项相关保护标志
			pte/pmd/pud/pgd_none
				相应表项为0, 则为1
			pte/pmd/pud/pgd_clear
				清除相应表一个表项, 由此禁止进程使用该表项映射线性地址	、
				ptep_get_and_clear()清除一个表项并返回前一个值
			set_pte/pmd/pud/pgd
				向一个页表项写入指定值
				set_pte_atomic, 当PAE激活时, 保证64位值被原子写入
			__pte/pmd/pud/pgd
				将无符号整数转换为所需要的类型
			pte/pmd/pud/pgd_val
				将特殊类型转换为无符号整数
			pte_same
				两个页表项指向同一页并且指定相同的访问优先级, 则返回1
			pmd_large
				如果页中间目录项指向一个大型页, 那么返回1
			pmd_bad
				如果目录项指向一个不能使用的页表(P/RW/A/D标志位清除), 则为1
			pte/pud/pgd_bad
				pud/pgd总是0, 无pte_bad, 页表项引用一个不在主页/不可写/无法访问均合法
			pte/pmd/pud/pgd_present
				一个页表项P/PS标志为1, 则返回1, pud/pgd总是1,
				  存在于主存没有读写或执行, 内核将P和PS位设置为0和1, 访问这些页均产生缺页异常
				然后通过PS位判断是不是缺页
			读页标志函数
				pte_user/read/write/exec/dirty/young/file
					读各标志位, 除file外, 当present位为1才有效,
					pte_file(当present被清除, Drity被设置时, 属于一个非线性磁盘文件映射)
			设置标志
				mk_pte_huge 设置PS与P位
				pte_wr/rd/exprotect/ pte_mkclean/old  清除标志
				pte_mkwrite/read/exec/dirty/young 设置标志位
				pte_modify 页表项所有访问权限设置为
				ptep_set_wrprotect 作用与指向页表项指针功能与pte_wrproct类似
				ptep_set_access_flags 如果dirty标志位1, 将页存取权限设置指定值, 并调用flush_tlb_page
				ptep_mkdirty 作用与指向页表项指针功能与pte_mkdirty类似
				ptep_test_and_clear_dirty 作用与指向页表项指针功能与pte_mkdclean类似, 并返回dirty标志
				ptep_test_and_clear_young 作用与指向页表项指针功能与pte_mkold类似, 并返回accessed标志
			表2-7 P81
