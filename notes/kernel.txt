
内存寻址
	MMU(内存控制单元)
		逻辑地址: 机器指令中指定一个操作数或一条指令的地址, 组成: 段选择符(16bit) + 偏移量(32bit)
		逻辑地址 --分段单元--> 线性地址 --分页单元--> 物理地址
		段选择符 ----> 描述符表(查找) --> +偏移量 = 虚拟地址
	内存仲裁器
		多个CPU共享内存, RAM芯片由独立CPU并发访问, RAM空闲准许一个CPU访问
	分段
		cs, ss, ds, es, fs, gs六个段寄存器, 存放段选择符
		cs: 代码段寄存器, 指向包含程序指令的段, 包含特权级0~3, 0内核态, 3用户态
		ss: 栈寄存器, 指向包含当前程序栈的段
		ds: 数据段, 指向包含静态数据或者全局数据段

		段选择符
			通常包含三个字段
				index: 放在GDT/LDT中的对应偏移(13bit)
				TI: 0代表在GDT中, 1代表在LDT中(1bit)
				RPL: 相应段放入CS中时, 指示CPU当前的特权级(2bit)
			GDT/LDT内段描述符 = 段选择符13bit*8
			GDT地址 = 0x00020000(保存在gdtr寄存器中)
			段选择符索引号 = 2
			段描述符所在地址 = 0x00020000 + (2 << 3) = 0x00020010
			GDT中第一项总是0, GDT存放段描述符最大数目为2^13 - 1 = 8191
		段描述符
			每一个段由8字节段描述符表示, 描述段特征, 放在全局描述符表(GDT)/局部描述符表(LDT)中
			通常定义一个GDT, 每个进程存放GDT段之外, 若有需要创建LDT, 
			GDT: GDT在主存的地址和大小放在gdtr控制寄存器中
			LDT: 当前正在被使用的LDT地址和大小放在ldtr控制寄存器中
			代码段描述符(64bit, 每一位均有含义)
				代表一个代码段, S标志为1
			数据段描述符(64bit, 每一位均有含义)
				代表一个数据段, 可以放在GDT或LDT中, S标志为1, 
			任务状态段描述符(64bit, 每一位均有含义)
				代表一个任务状态段, 段用于保护处理器寄存器的内容, 出现在GDT中, S标志为0
			局部描述符
				包含一个LDT段, 只出现在GDT中

		快速访问段描述符
			非编程的寄存器, 供6个可编程段寄存器使用
			 段选择符放入段寄存器中, 相应段描述符由内存装入对应的非编程寄存器中,
			针对那个段的逻辑地址转换, 可以不访问主存中GDT/LDT, 直接引用非编程寄存器, 
			当段寄存器内容改变时, 才有必要访问GDT/LDT

		分段单元
			1.检查段选择符TI字段, 决定段描述符保存在哪一个描述符表中, 从gdtr/ldtr获取基地址
			2.计算index得到段描述符, 将偏移量 + 段描述符Base字段 = 线性地址

		Linux中的分段
			只有在2.6版80x86架构下才使用分段
				1.当所有进程使用相同段寄存器时, 内存管理简单, 共享同一组线性地址
			第二章Linux中的分段

	分页
		页
			  线性地址分为固定长度单位的组, 页内部线性地址映射到连续的物理内存中,可以指定
			可以指定一个页的物理地址与存取权限, 而不用指定页所包含的全部线性地址的存取权限
			页指一组线性地址, 又指包含在这组地址中的数据
		页框
			  将所有RAM分成固定长度的页框(或者叫物理页), 每一个页框包含一个页,
			页框是主存的一部分, 页是一个数据块, 可以放在任何页框或者磁盘中
		页表
			线性地址映射到物理的数据结构, 存在主存中, 启用分页单元之前, 由内核对页表初始化
		分页单元
			访问类型与线性地址的访问权限比较, 若内存访问无效产生缺页异常, 处理4KB页
		常规分页
			页大小4KB
			32线性地址划分
				dir(页目录10bit) + table(页表10bit) + offset(12bit)
			使用一级页表: 2^20个页表项(高20bit都可以检索页表), 一个4B, 共占用4MB内存空间
			为每个活动进程分配页目录, 但实际需要一个页表时才给页表分配RAM
			CR3寄存器: 正在使用的页目录的物理地址
			页表基地址 = 页目录项 = CR3 + 页目录
			页表项 = 页表基地址 + 页表
			物理地址 = 页表项 + offset
			页目录/页表项包含字段
				高20字段
					每一个页框4KB容量, 物理地址必须2^12倍数, 因此低12位全为0
					字段指向一个页目录,则相应页框就有一个页表
					指向一个页表,则相应页框就有页数据
				低12位
					P: 为1表示页表或者页位于内存中, 否则, 表示不在内存中, 将线性地址放入CR2寄存器中, 产生14号中断, 必须先予以创建或者从磁盘调入内存后方可使用
					R/W: 读写标志。为1表示页面可以被读写, 为0表示只读。当处理器运行在0、1、2特权级时, 此位不起作用。页目录中的这个位对其所映射的所有页面起作用
					U/S: 用户/超级用户标志。为1时, 允许所有特权级别的程序访问；为0时, 仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用
					PWT: Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉）, 此标志被忽略。对于我们的实验, 此位清零
					PCD: Page级的Cache Disable标志位。为1时, 物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时, 此标志被忽略。对于我们的实验, 此位清零
					A: 访问位。该位由处理器固件设置, 用来指示此表项所指向的页是否已被访问（读或写）, 一旦置位, 处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率
					D: 脏位。该位由处理器固件设置, 用来指示此表项所指向的页是否写过数据
					PS: Page Size位。为0时, 页的大小是4KB；为1时, 页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled)
					G: 全局位。如果页是全局的, 那么它将在高速缓存中一直保存。当CR4.PGE=1时, 可以设置此位为1, 指示Page是全局Page, 在CR3被更新时, TLB内的全局Page不会被刷新
					AVL[11]: 被处理器忽略, 软件可以使用
		扩展分页
			允许页大小为4MB
			32线性地址划分
				dir(页目录10bit) + offset(22bit)
			通过设置CR4寄存器的PSE标志使扩展分页与常规内存分页共存
		例子
			已经分配给进程空间0x20000000~0x2003ffff, 64页
			dir = 0x80 --> 页目录第129项含有页表基地址
			table = 0x~0x03f --> 页表项中前64个有意义
			读取线性地址0x20021406中数据
				dir = 0x80 --> 选择页目录第0x80项查找页表
				table = 0x21 --> 选择页表中第0x21表项查找物理地址
				offset = 0x406 --> 读取物理地址偏移0x406中字节
				如果table中present标志位0, 产生缺页异常, 进程访问范围外地址, 均产生缺页异常
		物理地址扩展分页
			32位线性地址转换为36位物理地址可寻址2^36 = 64GB
			通过设置CR4中PAE标志激活PAE, 页目录项中的大小标志改为2MB
			引入页目录指针表(PDPT), 由4个64位表项组成
			CR3包含一个27位页目录指针表基地址, PDPT存放在RAM中前4GB中, 并在32bytes倍数对齐
			映射到4KB时
				CR3 指向PDPT
				pdpt表项(2bit) + dir(页表9bit) + table (9bit)+ offset(12bit)
			映射到2MB时
				CR3 指向PDPT
				pdpt表4项中的一个(2bit) + dir(页表8bit) + offset(21bit)
		硬件高速缓存
			73页(cache)
		TLB
			  线性地址第一次被使用时, 通过慢速访问RAM中页表计算出相应的物理地址,
			同时物理地址存放在TLB表项中, 以便以后对同一个线性地址引用可快速转换
			  每一个CPU上都有TLB表, 当CPU的CR3寄存器被修改时, 硬件使本地TLB所有项无效

	Linux中的分页
		采用4级分页(兼容32和64bit系统)
			PGD + PUD + PMD + PT + offset
			对于两级页表足够系统(32bit), 页上级目录(PUD)和页中间目录(PMD)均为0
		  每一个进程有自己的页全局目录, 发生进程切换时, 把CR3寄存器的内容保存执行进程的描述符中
		将下一个要执行的进程描述符装入CR3中
		线性地址字段
			PAGE_SHIFT
				值为12, 指定offset位数, 页大小4KB, PAGE_MASK(0xfffff000)屏蔽offset所有位
			PMD_SHIFT
				offset与table字段总位数
				PAE禁用时, 值为22(offset 12bit + table 10bit)
				PAE激活时, 值为21(offset 12bit + table 9bit)
			PUD_SHIFT
				32位中等价于PMD_SHIFT
			PGDIR_SHIFT
				PAE禁用时, 值为22(offset 12bit + table 10bit, 同PMD_SHIFT)
				PAE激活时, 值为30(offset 12bit + table 9bit + PMD 9bit)
			PTRS_PER_PTE/PME/PUD/PGD
				计算页表/页中间目录/页上级目录/页全局目录中表项个数
				PAE禁用时, 值分别为1024, 1, 1, 1024
				PAE激活时, 值分别为512, 512, 1, 4
		页表处理
			PAE激活时, 下列数据类型均为64位, 否则32位
			pte/pmd/pud/pgd/pgprot_t
				页表项, 页中间目录项, 页上级目录项, 页全局目录项, 单独表项相关保护标志
			pte/pmd/pud/pgd_none
				相应表项为0, 则为1
			pte/pmd/pud/pgd_clear
				清除相应表一个表项, 由此禁止进程使用该表项映射线性地址	、
				ptep_get_and_clear()清除一个表项并返回前一个值
			set_pte/pmd/pud/pgd
				向一个页表项写入指定值
				set_pte_atomic, 当PAE激活时, 保证64位值被原子写入
			__pte/pmd/pud/pgd
				将无符号整数转换为所需要的类型
			pte/pmd/pud/pgd_val
				将特殊类型转换为无符号整数
			pte_same
				两个页表项指向同一页并且指定相同的访问优先级, 则返回1
			pmd_large
				如果页中间目录项指向一个大型页, 那么返回1
			pmd_bad
				如果目录项指向一个不能使用的页表(P/RW/A/D标志位清除), 则为1
			pte/pud/pgd_bad
				pud/pgd总是0, 无pte_bad, 页表项引用一个不在主页/不可写/无法访问均合法
			pte/pmd/pud/pgd_present
				一个页表项P/PS标志为1, 则返回1, pud/pgd总是1,
				  存在于主存没有读写或执行, 内核将P和PS位设置为0和1, 访问这些页均产生缺页异常
				然后通过PS位判断是不是缺页
			读页标志函数
				pte_user/read/write/exec/dirty/young/file
					读各标志位, 除file外, 当present位为1才有效,
					pte_file(当present被清除, Drity被设置时, 属于一个非线性磁盘文件映射)
			设置标志
				mk_pte_huge 设置PS与P位
				pte_wr/rd/exprotect/ pte_mkclean/old  清除标志
				pte_mkwrite/read/exec/dirty/young 设置标志位
				pte_modify 页表项所有访问权限设置为
				ptep_set_wrprotect 作用与指向页表项指针功能与pte_wrproct类似
				ptep_set_access_flags 如果dirty标志位1, 将页存取权限设置指定值, 并调用flush_tlb_page
				ptep_mkdirty 作用与指向页表项指针功能与pte_mkdirty类似
				ptep_test_and_clear_dirty 作用与指向页表项指针功能与pte_mkdclean类似, 并返回dirty标志
				ptep_test_and_clear_young 作用与指向页表项指针功能与pte_mkold类似, 并返回accessed标志
			对页表操作的宏
				pgd/pud/pmd_index 找到线性地址addr对应的目录项中的索引
				pgd_offset 接收内存地址描述符mm, 和线性地址addr为参数, 产生addr在页全局目录中相应表项的线性地址
					通过内存描述符中的一个指针找到页全局目录
				pgd_offset_k 产生主内核也全局目录总的某个线性地址, 该项对应于地址addr
				pgd_page 通过页全局目录项pgd, 产生页上级目录所在页框的页描述符地址, 在2/3级分页中等价于pud_page
				pud_offset 接收页全局目录项指针pgd, 和线性地址addr为参数, 产生addr在页上级目录中相应表项的线性地址
				pud_page 通过页上级目录项pud产生页中间目录线性地址, 在2分页中等价于pmd_page
				pmd_offset 接收页上级目录项指针pud, 和线性地址addr为参数, 产生addr在目录项中相应表项的线性地址
				pmd_page 通过页中间目录项pmd产生对应页表描述符地址, 在2/3级分页系统中, pmd实际上是页全局目录中一项
				mk_pte 接收页描述符地址p和一组存取权限prot作为参数并创建相应的页表项
				pte_offset_map 接收向一个页中间目录项指针dir和线性地址addr, 产生与线性地址addr相应的页表项的线性地址
					如果页表被保存在高端内存中, 那么建立一个临时内核映射, 并用pte_unmap进行释放,
					pte_offset_mao_nested, pte_unmap_nested这两个宏功能相同但使用不同内核映射
				pte_page 返回页表项x所引用页的描述符地址
				pte_to_pgoff 从一个页表项pte字段内容提取出文件偏移量, 偏移量对应着一个非线性文件内存映射所在页
				pgoff_to_pte 为非线性文件内存映射所在的页创建对应页表项的内容
			页分配函数
				pgd_alloc 分区一个全新的页全局目录, 如果PAE被激活, 还分配三个对应用户态线性地址的子页中间
				pgd_free 释放页全局目录地址为pgd的项, 如果PAE被激活, 释放用户态线性地址对应的三个页中间目录
				pud/pmd_alloc, pud/pmd_free
				pte_alloc_map, pte_free 返回与addr对应的页表项地址, 如果页中间目录项为空,
					则调用pte_alloc_one分配一个新页表, 如果分配一个新页表, addr对应的项被创建
				pte_alloc_kernel, pte_free_kernel 主内核使用
		物理内存布局
			内核将下列页框记为保留
				在不可用的物理地址范围内的页框
				含有内核代码和已初始化的数据结构的页框
			保留页框决不能动态分配或交换到磁盘上
			内核一般安装在RAM中从物理地址0x00100000开始, 从第二个MB开始
				页框0由bios使用, 存放加电自检等配置, 初始化后数据写到页框中
				0x000a0000~0x000fffff通常留给bios例程, 并且映射ISA图形卡上的内部内存, IBM兼容PC上从640KB~1MB之间著名的洞
				第一个MB内的其他页框可能由特定计算机模型保留, 如0xA0~0x9F页框给IBM THinkpnd使用
			  启动过程的早期阶段, 询问BIOS并了解物理内存的大小, 内核调用BIOS过程建立一组物理地址范围及对应类型
			随后执行machine_specific_memory_setup, 建立物理地址映射, 如果可获取则在BIOS基础上构建, 否则缺省构建
			0x9F~0x100号所有页框标记为保留
			128MB RAM配置
				0x00000000~0x0009FFFF Usable
				0x000F0000~0x000FFFFF Reserved
				0x00100000~0x07FEFFFF Usable
				0x07FF0000~0x07FF2FFF ACPI data	存有加电自检阶段由BIOS写入的系统硬件设备信息
				0x07FF3000~0x07FFFFFF ACPI NVS	映射到硬件ROM芯片
				0xFFFF0000~0xFFFFFFFF Reserved	由硬件映射到BIOS的ROM芯片
				0x000A0000~0x000EFFFF BIOS并不提供信息, Linux假定不可用
			machine_specific_memory_setup --> setup_memory(分析物理内存区域, 并初始化一些变量描述内核的物理内存布局)
				num_physpages	最高可用页框号
				totalram_pages	可用页框总数量
				min_low_pfn		RAM中在内核映像后第一个可用页框号
				max_pfn			最后一个可用页框号
				max_low_pfn		被内核直接映射的最后一个页框号(低地址内存)
				totalhigh_pages	内核非直接映射的页框总数
				highstart_pfn	内核非直接映射的第一个页框号
				highend_pfn		内核非直接映射的最后一个页框号
			内核符号
				_text(内核代码开始)~_etext(内核代码结束位置, 初始化过数据)~_edata(未初始化数据)~_end
				编译内核时产生, System.map找到符号的线性地址
		进程页表
			0x00000000~0xBFFFFFFF	内核态和用户态均可访问(进程运行在用户态时, 产生线性地址范围)
			0xC0000000~0xFFFFFFFF	内核态访问(进程运行在内核态时, 产生线性地址范围)
				3GB ~ 3GB + 896MB <--> 0 ~ 896MB 物理地址
				3GB + 896MB ~ 4GB 实现非连续分配内存和固定映射
			PAGE_OFFSET值为0xC0000000, 进程在线性地址中的偏移量, 内核空间开始
			页全局目录的第一部分页表项映射的线性地址小于PAGE_OFFSET(共1024项, PAE未启用时前768项, 启用后为前3项, 剩余的表项对所有进程相同)
		内核页表
			1.对内核的数据结构进行管理
			2.页表部分作为参考模型
			临时页全局目录, 在内核编译过程中静态初始化, 由startup_32函数临时页表
			  临时页全局目录放在swapper_pg_dir变量中, 临时页表在pg0变量处开始存放, 紧接着在_end后
			内核代码段和数据段, 初始化页表和128KB内存范围能容纳于RAM前8MB, 需要用两个页表映射(2*1024*4K = 8MB(一个页表1024项))
			第一阶段
				允许在实模式和保护模式下都能容易访问8MB, 内核创建映射
				0x00000000~0x007FFFFF 通过与物理地址相同的线性地址进行访问
				0xC0000000~0xC07FFFFF --> 0x00000000~0x007FFFFF 通过0xC0000000~0xC07FFFFF线性地址进行访问
				内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射, 不过0, 1, 0x300(Dec 768), 0x301这四项除外, 后两项包含0xC0000000~0xC07FFFFF映射全部映射
					1.0项和0x300项的地址字段置为pg0的物理地址, 而1项和0x301的地址字段置为紧随pg0后的页框的物理地址
					2.四个项中的P, R/W, U/S置位. A, D, PS, PWT, PCD位清零
				startup_32启用分页单元, 通过向CR3控制寄存器装入swapper_pg_dir的地址及设置PG标志达到目的
		RAM小于896MB最终内核页表
			内核页表所提供的最终映射从0xC0000000开始的线性地址转化为从0开始的物理地址
			__pa把从PAGE_OFFSET开始的线性地址转换为物理地址, __va物理地址转换为线性地址
			主内核页全局目录任然保存在swapper_pg_dir变量中, 有paging_init函数初始化
				1.调用pagetable_init适当建立页表项
				2.把swapper_pg_dir的物理地址写入CR3控制寄存器中
				3.如果CPU支持PAE且编译选项支持PAE, 将CR4控制寄存器的PAE标志置位
				4.调用__flush_tlb_all使TLB的所有项无效
			RAM小于896MB, 无需激活PAE循环初始化, pgd = swapper_pg_dir + pgd_index(PGAE_OFFSET) /* 第768项 */
				P90
			假定CPU支持4MB页, 和全局TLB表项U/S位清零拒绝用户态进程访问, PS置位可以使用大型页对RAM寻址, 
			startup_32创建的物理内存前8MB恒等映射完来完成初始化后, 这种映射不需要时, 调用zap_low_mappings清除对应的页表项
		RAM大小896MB~4096MB之间的最终内核页表
			  并不把RAM全部映射到内核地址空间, 在初始化阶段最好把一个具有896MB的RAM窗口映射到内核线性地址空间,
			如果一个程序需要对现有RAM的其余部分寻址, 必须把某些其他的线性地址间隔映射到所需的RAM, 即动态重映射
		RAM大于4096MB最终内核页表
			RAM大于4GB时以下情况
				1.CPU支持物理地址扩展PAE
				2.RAM容量大于4GB
				3.内核以PAE支持来编译
			  尽管PAE是处理36位物理地址, 但线性地址依然是32位, 映射一个896MB的RAN窗口到内核线性地址空间, 剩余RAM留着不映射
			并由动态重映射处理
				P91
			  页全局目录中的前三项与用户线性地址空间相对应, 用一个空页(empty_zero_page)的地址对这三项初始化
			第四项用页中间目录(pmd)初始化, 调用alloc_bootmem_low_pages分配(前448项用RAM前896MB填充(有512项但后64项给非连续内存分配和固定映射))
			然后页全局目录的第四项被拷贝到第一项中, 好为线性地址空间的前896MB中的低物理内存映射作为镜像, 当映射不必要时调用zap_low_mappings清除
		固定映射的线性地址
			内核线性地址第4个GB的初始化部分映射系统的物理内存, 至少128MB的线性地址总是留作他用, 内核是使用这些线性地址实现非连续内存分配和固定映射
			  固定的线性地址类似0xFFFFC000的常量地址, 其对应的物理地址不必等于线性地址减去0xC0000000, 而是可以通过任意方式建立
			每个固定映射的线性地址都映射一个物理内存的页框, 固定线性地址存放在线性地址第4个GB的末端, 定义在enum fixed_addresses, fix_to_virt计算
			从给定索引开始的常量线性地址
			  为了把一个物理地址与固定映射的线性地址关联, 使用set_fixmap和set_fixmap_nocache宏, 把线性地址对应的一个页表项初始化为物理地址phys
			第二个函数将页表项PCD标志置位, 当访问页框中的数据时禁用硬件告诉缓存, 使用clear_fixmap撤销固定线性地址与物理地址的关联
	处理硬件高速缓存和TLB
		处理硬件高速缓存
			为了让高速缓存命中率达到最优化, 采用以下策略
				1.一个数据结构中最常用的字段放在该数据结构内的低偏移部分, 以便能够处于高速缓存同一行中
				2.当为一组大数据结构分配空间时, 试图将它们存放在内存中, 以便所有高速缓存行按同一方式处理
		TLB
			处理器不能自动同步它们自己的TLB高速缓存, 内核提供适当时机运用TLB刷新方法
				格式: 方法名称 说明 使用时机
				flush_tlb_all 刷新所有TLB表项 改变内核页表项时
				flush_tlb_kernel_rang 刷新给定线性地址范围内所有TLB表项 更换一个范围内的内核页表项
				flush_tlb 刷新当前进程拥有的非全局页相关的所有TLB表项 进程切换时候
				flush_tlb_mm 刷新指定进程拥有的非全局页相关的所有TLB表项 创建一个新的子进程时
				flush_tlb_mm_range 刷新指定进程的线性地址间隔对应的TLB表项 释放某个进程的线性地址间隔时
				flush_tlb_pgtables 刷新指定进程中特定的相临页表集相关的TLB表项 释放进程的一些页表时
				flush_tlb_page 刷新指定进程中单个页表项相关的TLB表项 处理缺页异常时
			intel只提供两种使TLB无效的技术
				1.向CR3寄存器写入值时所有Pentium处理器自动刷新相对于非全局页的TLB表项
				2.在Pentium Pro及以后处理器中, invlpg汇编语言指令使映射指定线性地址单个TLB表项无效
			采用刷新TLB中宏, 实现独立于系统的方法不刷
				格式: 宏名称 描述 使用对象1, 使用对象2, ...
				__flush_tlb 将CR3寄存器当前的值重新写回CR3 flusb_tlb, flusb_tlb_mm, flush_tlb_range
				__flush_tlb_global 清除CR4的PGE标志禁用全局页, 将CR3值重新写回CR3, 并在次设置PGE标志 flush_tlb_all, flush_tlb_kernel_rang
				__flush_tlb_single 以addr为参数执行invlpg汇编语音指令 flush_tlb_page
				x86系统中无flush_tlb_pgtables, 所以实现这个方法函数为空
			一般来说进程切换更换活动页表, 相对于过期页表, 本地TLB必须刷新, 将新的pgd地址写入CR3中自动完成, 不过在以下情况避免TLB刷新
				1.两个使用相同页表集的普通进程之间执行进程切换时
				2.当一个普通进程和一个内核线程间执行进程切换时
				3.当某个用户态进程分配页框并将它的物理地址存入页表项时
			为了避免无用的TLB刷新, 采用懒惰TLB模式技术, 几个CPU使用相同页表, 必须对这些CPU上的TLB表项刷新, 那么运行内核线程的CPU可以延迟刷新
			内核线程并不拥有自己的页表集, 它使用普通进程的页表集, 没必要使一个用户态线性地址对应的TLB表项无效, 因为内核线程不访问内核地址空间
			  当某个CPU运行内核线程时, 将置为懒惰TLB, 当发出清除TLB表项请求时, 处于懒惰TLB模式的CPU不刷新相应表项,
			但CPU记住当前进程正在运行在一组页表上, 而这组页表的TLB表项对用户态地址是无效, 只要处于懒惰TLB模式的CPU
			用一个不同的页表集切换到一个普通进程, 硬件自动刷新, 同时把CPU设为非懒惰TLB, 然而, 如果处于懒惰TLB的CPU
			切换到的进程与刚才运行的内核线程拥有相同的页表集, 那么任何使TLB无效的延迟操作必须由内核有效地实施,
			这种操作可以通过刷新CPU所有非全局TLB项有效获取
			懒惰TLB模式数据结构
				cpu_talbstate 变量是一个具有NR_CPUS个结构的静态数组, 默认32, 有两个字段
					1.指向当前进程内存描述符的active_mm字段
					2.具有两个状态值的state字段: TLBSTATE_OK, TLBSTATE_LAZY
				  此外内存描述符中包含一个cpu_vm_mask字段, 该字段存放的是CPU(这些CPU将要接收与TLB刷新相关的处理器间中断)下标,
				只有内存描述符属于当前运行进程时才有意义
			流程
				  执行内核线程, cpu_talbstate中state字段置为TLBSTATE_LAZY, 此外活动内存描述符(用户mm_struct)的cpu_vm_mask存放系统中所有CPU的下标
				当另一个CPU想使这些表项无效时, 该CPU就把一个处理器间中断发送给下标处于对应内存描述符的cpu_vm_mask字段中的CPU,
				  当CPU接收到一个与TLB刷新相关的处理器间中断, 并验证它影响当前进程的页表集时, 检查是否处于懒惰, 如果处于懒惰模式, 拒绝TLB表项刷新
				并从内存描述符中cpu_vm_mask字段删除该CPU下标, 这有两种结果
					1.CPU处于懒惰模式, 将不接受其他与TLB刷新相关的处理器间中断
					2.如果CPU切换到另一个进程, 而这个进程与刚被替换的内核线程使用相同的页表集, 调用__flush_tlb使该CPU的所有非全局TLB表项无效

进程
	P98
