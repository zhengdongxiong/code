
内存寻址
	MMU(内存控制单元)
		逻辑地址: 机器指令中指定一个操作数或一条指令的地址, 组成: 段选择符(16bit) + 偏移量(32bit)
		逻辑地址 --分段单元--> 线性地址 --分页单元--> 物理地址
		段选择符 ----> 描述符表(查找) --> +偏移量 = 虚拟地址
	内存仲裁器
		多个CPU共享内存, RAM芯片由独立CPU并发访问, RAM空闲准许一个CPU访问
	分段
		cs, ss, ds, es, fs, gs六个段寄存器, 存放段选择符
		cs: 代码段寄存器, 指向包含程序指令的段, 包含特权级0~3, 0内核态, 3用户态
		ss: 栈寄存器, 指向包含当前程序栈的段
		ds: 数据段, 指向包含静态数据或者全局数据段

		段选择符
			通常包含三个字段
				index: 放在GDT/LDT中的对应偏移(13bit)
				TI: 0代表在GDT中, 1代表在LDT中(1bit)
				RPL: 相应段放入CS中时, 指示CPU当前的特权级(2bit)
			GDT/LDT内段描述符 = 段选择符13bit*8
			GDT地址 = 0x00020000(保存在gdtr寄存器中)
			段选择符索引号 = 2
			段描述符所在地址 = 0x00020000 + (2 << 3) = 0x00020010
			GDT中第一项总是0, GDT存放段描述符最大数目为2^13 - 1 = 8191
		段描述符
			每一个段由8字节段描述符表示, 描述段特征, 放在全局描述符表(GDT)/局部描述符表(LDT)中
			通常定义一个GDT, 每个进程存放GDT段之外, 若有需要创建LDT, 
			GDT: GDT在主存的地址和大小放在gdtr控制寄存器中
			LDT: 当前正在被使用的LDT地址和大小放在ldtr控制寄存器中
			代码段描述符(64bit, 每一位均有含义)
				代表一个代码段, S标志为1
			数据段描述符(64bit, 每一位均有含义)
				代表一个数据段, 可以放在GDT或LDT中, S标志为1, 
			任务状态段描述符(64bit, 每一位均有含义)
				代表一个任务状态段, 段用于保护处理器寄存器的内容, 出现在GDT中, S标志为0
			局部描述符
				包含一个LDT段, 只出现在GDT中

		快速访问段描述符
			非编程的寄存器, 供6个可编程段寄存器使用
			 段选择符放入段寄存器中, 相应段描述符由内存装入对应的非编程寄存器中,
			针对那个段的逻辑地址转换, 可以不访问主存中GDT/LDT, 直接引用非编程寄存器, 
			当段寄存器内容改变时, 才有必要访问GDT/LDT

		分段单元
			1.检查段选择符TI字段, 决定段描述符保存在哪一个描述符表中, 从gdtr/ldtr获取基地址
			2.计算index得到段描述符, 将偏移量 + 段描述符Base字段 = 线性地址

		Linux中的分段
			只有在2.6版80x86架构下才使用分段
				1.当所有进程使用相同段寄存器时, 内存管理简单, 共享同一组线性地址
			第二章Linux中的分段

	分页
		页
			  线性地址分为固定长度单位的组, 页内部线性地址映射到连续的物理内存中,可以指定
			可以指定一个页的物理地址与存取权限, 而不用指定页所包含的全部线性地址的存取权限
			页指一组线性地址, 又指包含在这组地址中的数据
		页框
			  将所有RAM分成固定长度的页框(或者叫物理页), 每一个页框包含一个页,
			页框是主存的一部分, 页是一个数据块, 可以放在任何页框或者磁盘中
		页表
			线性地址映射到物理的数据结构, 存在主存中, 启用分页单元之前, 由内核对页表初始化
		分页单元
			访问类型与线性地址的访问权限比较, 若内存访问无效产生缺页异常, 处理4KB页
		常规分页
			页大小4KB
			32线性地址划分
				dir(页目录10bit) + table(页表10bit) + offset(12bit)
			使用一级页表: 2^20个页表项(高20bit都可以检索页表), 一个4B, 共占用4MB内存空间
			为每个活动进程分配页目录, 但实际需要一个页表时才给页表分配RAM
			CR3寄存器: 正在使用的页目录的物理地址
			页表基地址 = 页目录项 = CR3 + 页目录
			页表项 = 页表基地址 + 页表
			物理地址 = 页表项 + offset
			页目录/页表项包含字段
				高20字段
					每一个页框4KB容量, 物理地址必须2^12倍数, 因此低12位全为0
					字段指向一个页目录,则相应页框就有一个页表
					指向一个页表,则相应页框就有页数据
				低12位
					P: 为1表示页表或者页位于内存中, 否则, 表示不在内存中, 将线性地址放入CR2寄存器中, 产生14号中断, 必须先予以创建或者从磁盘调入内存后方可使用
					R/W: 读写标志。为1表示页面可以被读写, 为0表示只读。当处理器运行在0、1、2特权级时, 此位不起作用。页目录中的这个位对其所映射的所有页面起作用
					U/S: 用户/超级用户标志。为1时, 允许所有特权级别的程序访问；为0时, 仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用
					PWT: Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉）, 此标志被忽略。对于我们的实验, 此位清零
					PCD: Page级的Cache Disable标志位。为1时, 物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时, 此标志被忽略。对于我们的实验, 此位清零
					A: 访问位。该位由处理器固件设置, 用来指示此表项所指向的页是否已被访问（读或写）, 一旦置位, 处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率
					D: 脏位。该位由处理器固件设置, 用来指示此表项所指向的页是否写过数据
					PS: Page Size位。为0时, 页的大小是4KB；为1时, 页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled)
					G: 全局位。如果页是全局的, 那么它将在高速缓存中一直保存。当CR4.PGE=1时, 可以设置此位为1, 指示Page是全局Page, 在CR3被更新时, TLB内的全局Page不会被刷新
					AVL[11]: 被处理器忽略, 软件可以使用
		扩展分页
			允许页大小为4MB
			32线性地址划分
				dir(页目录10bit) + offset(22bit)
			通过设置CR4寄存器的PSE标志使扩展分页与常规内存分页共存
		例子
			已经分配给进程空间0x20000000~0x2003ffff, 64页
			dir = 0x80 --> 页目录第129项含有页表基地址
			table = 0x~0x03f --> 页表项中前64个有意义
			读取线性地址0x20021406中数据
				dir = 0x80 --> 选择页目录第0x80项查找页表
				table = 0x21 --> 选择页表中第0x21表项查找物理地址
				offset = 0x406 --> 读取物理地址偏移0x406中字节
				如果table中present标志位0, 产生缺页异常, 进程访问范围外地址, 均产生缺页异常
		物理地址扩展分页
			32位线性地址转换为36位物理地址可寻址2^36 = 64GB
			通过设置CR4中PAE标志激活PAE, 页目录项中的大小标志改为2MB
			引入页目录指针表(PDPT), 由4个64位表项组成
			CR3包含一个27位页目录指针表基地址, PDPT存放在RAM中前4GB中, 并在32bytes倍数对齐
			映射到4KB时
				CR3 指向PDPT
				pdpt表项(2bit) + dir(页表9bit) + table (9bit)+ offset(12bit)
			映射到2MB时
				CR3 指向PDPT
				pdpt表4项中的一个(2bit) + dir(页表8bit) + offset(21bit)
		硬件高速缓存
			73页(cache)
		TLB
			  线性地址第一次被使用时, 通过慢速访问RAM中页表计算出相应的物理地址,
			同时物理地址存放在TLB表项中, 以便以后对同一个线性地址引用可快速转换
			  每一个CPU上都有TLB表, 当CPU的CR3寄存器被修改时, 硬件使本地TLB所有项无效

	Linux中的分页
		采用4级分页(兼容32和64bit系统)
			PGD + PUD + PMD + PT + offset
			对于两级页表足够系统(32bit), 页上级目录(PUD)和页中间目录(PMD)均为0
		  每一个进程有自己的页全局目录, 发生进程切换时, 把CR3寄存器的内容保存执行进程的描述符中
		将下一个要执行的进程描述符装入CR3中
		线性地址字段
			PAGE_SHIFT
				值为12, 指定offset位数, 页大小4KB, PAGE_MASK(0xfffff000)屏蔽offset所有位
			PMD_SHIFT
				offset与table字段总位数
				PAE禁用时, 值为22(offset 12bit + table 10bit)
				PAE激活时, 值为21(offset 12bit + table 9bit)
			PUD_SHIFT
				32位中等价于PMD_SHIFT
			PGDIR_SHIFT
				PAE禁用时, 值为22(offset 12bit + table 10bit, 同PMD_SHIFT)
				PAE激活时, 值为30(offset 12bit + table 9bit + PMD 9bit)
			PTRS_PER_PTE/PME/PUD/PGD
				计算页表/页中间目录/页上级目录/页全局目录中表项个数
				PAE禁用时, 值分别为1024, 1, 1, 1024
				PAE激活时, 值分别为512, 512, 1, 4
		页表处理
			PAE激活时, 下列数据类型均为64位, 否则32位
			pte/pmd/pud/pgd/pgprot_t
				页表项, 页中间目录项, 页上级目录项, 页全局目录项, 单独表项相关保护标志
			pte/pmd/pud/pgd_none
				相应表项为0, 则为1
			pte/pmd/pud/pgd_clear
				清除相应表一个表项, 由此禁止进程使用该表项映射线性地址	、
				ptep_get_and_clear()清除一个表项并返回前一个值
			set_pte/pmd/pud/pgd
				向一个页表项写入指定值
				set_pte_atomic, 当PAE激活时, 保证64位值被原子写入
			__pte/pmd/pud/pgd
				将无符号整数转换为所需要的类型
			pte/pmd/pud/pgd_val
				将特殊类型转换为无符号整数
			pte_same
				两个页表项指向同一页并且指定相同的访问优先级, 则返回1
			pmd_large
				如果页中间目录项指向一个大型页, 那么返回1
			pmd_bad
				如果目录项指向一个不能使用的页表(P/RW/A/D标志位清除), 则为1
			pte/pud/pgd_bad
				pud/pgd总是0, 无pte_bad, 页表项引用一个不在主页/不可写/无法访问均合法
			pte/pmd/pud/pgd_present
				一个页表项P/PS标志为1, 则返回1, pud/pgd总是1,
				  存在于主存没有读写或执行, 内核将P和PS位设置为0和1, 访问这些页均产生缺页异常
				然后通过PS位判断是不是缺页
			读页标志函数
				pte_user/read/write/exec/dirty/young/file
					读各标志位, 除file外, 当present位为1才有效,
					pte_file(当present被清除, Drity被设置时, 属于一个非线性磁盘文件映射)
			设置标志
				mk_pte_huge 设置PS与P位
				pte_wr/rd/exprotect/ pte_mkclean/old  清除标志
				pte_mkwrite/read/exec/dirty/young 设置标志位
				pte_modify 页表项所有访问权限设置为
				ptep_set_wrprotect 作用与指向页表项指针功能与pte_wrproct类似
				ptep_set_access_flags 如果dirty标志位1, 将页存取权限设置指定值, 并调用flush_tlb_page
				ptep_mkdirty 作用与指向页表项指针功能与pte_mkdirty类似
				ptep_test_and_clear_dirty 作用与指向页表项指针功能与pte_mkdclean类似, 并返回dirty标志
				ptep_test_and_clear_young 作用与指向页表项指针功能与pte_mkold类似, 并返回accessed标志
			对页表操作的宏
				pgd/pud/pmd_index 找到线性地址addr对应的目录项中的索引
				pgd_offset 接收内存地址描述符mm, 和线性地址addr为参数, 产生addr在页全局目录中相应表项的线性地址
					通过内存描述符中的一个指针找到页全局目录
				pgd_offset_k 产生主内核也全局目录总的某个线性地址, 该项对应于地址addr
				pgd_page 通过页全局目录项pgd, 产生页上级目录所在页框的页描述符地址, 在2/3级分页中等价于pud_page
				pud_offset 接收页全局目录项指针pgd, 和线性地址addr为参数, 产生addr在页上级目录中相应表项的线性地址
				pud_page 通过页上级目录项pud产生页中间目录线性地址, 在2分页中等价于pmd_page
				pmd_offset 接收页上级目录项指针pud, 和线性地址addr为参数, 产生addr在目录项中相应表项的线性地址
				pmd_page 通过页中间目录项pmd产生对应页表描述符地址, 在2/3级分页系统中, pmd实际上是页全局目录中一项
				mk_pte 接收页描述符地址p和一组存取权限prot作为参数并创建相应的页表项
				pte_offset_map 接收向一个页中间目录项指针dir和线性地址addr, 产生与线性地址addr相应的页表项的线性地址
					如果页表被保存在高端内存中, 那么建立一个临时内核映射, 并用pte_unmap进行释放,
					pte_offset_mao_nested, pte_unmap_nested这两个宏功能相同但使用不同内核映射
				pte_page 返回页表项x所引用页的描述符地址
				pte_to_pgoff 从一个页表项pte字段内容提取出文件偏移量, 偏移量对应着一个非线性文件内存映射所在页
				pgoff_to_pte 为非线性文件内存映射所在的页创建对应页表项的内容
			页分配函数
				pgd_alloc 分区一个全新的页全局目录, 如果PAE被激活, 还分配三个对应用户态线性地址的子页中间
				pgd_free 释放页全局目录地址为pgd的项, 如果PAE被激活, 释放用户态线性地址对应的三个页中间目录
				pud/pmd_alloc, pud/pmd_free
				pte_alloc_map, pte_free 返回与addr对应的页表项地址, 如果页中间目录项为空,
					则调用pte_alloc_one分配一个新页表, 如果分配一个新页表, addr对应的项被创建
				pte_alloc_kernel, pte_free_kernel 主内核使用
		物理内存布局
			内核将下列页框记为保留
				在不可用的物理地址范围内的页框
				含有内核代码和已初始化的数据结构的页框
			保留页框决不能动态分配或交换到磁盘上
			内核一般安装在RAM中从物理地址0x00100000开始, 从第二个MB开始
				页框0由bios使用, 存放加电自检等配置, 初始化后数据写到页框中
				0x000a0000~0x000fffff通常留给bios例程, 并且映射ISA图形卡上的内部内存, IBM兼容PC上从640KB~1MB之间著名的洞
				第一个MB内的其他页框可能由特定计算机模型保留, 如0xA0~0x9F页框给IBM THinkpnd使用
			  启动过程的早期阶段, 询问BIOS并了解物理内存的大小, 内核调用BIOS过程建立一组物理地址范围及对应类型
			随后执行machine_specific_memory_setup, 建立物理地址映射, 如果可获取则在BIOS基础上构建, 否则缺省构建
			0x9F~0x100号所有页框标记为保留
			128MB RAM配置
				0x00000000~0x0009FFFF Usable	
				0x000F0000~0x000FFFFF Reserved
				0x00100000~0x07FEFFFF Usable
				0x07FF0000~0x07FF2FFF ACPI data	存有加电自检阶段由BIOS写入的系统硬件设备信息
				0x07FF3000~0x07FFFFFF ACPI NVS	映射到硬件ROM芯片
				0xFFFF0000~0xFFFFFFFF Reserved	由硬件映射到BIOS的ROM芯片
				0x000A0000~0x000EFFFF BIOS并不提供信息, Linux假定不可用
			machine_specific_memory_setup --> setup_memory(分析物理内存区域, 并初始化一些变量描述内核的物理内存布局)
				num_physpages	最高可用页框号
				totalram_pages	可用页框总数量
				min_low_pfn		RAM中在内核映像后第一个可用页框号
				max_pfn			最后一个可用页框号
				max_low_pfn		被内核直接映射的最后一个页框号(低地址内存)
				totalhigh_pages	内核非直接映射的页框总数
				highstart_pfn	内核非直接映射的第一个页框号
				highend_pfn		内核非直接映射的最后一个页框号
			内核符号
				_text(内核代码开始)~_etext(内核代码结束位置, 初始化过数据)~_edata(未初始化数据)~_end
				编译内核时产生, System.map找到符号的线性地址
		进程页表
			0x00000000~0xBFFFFFFF	内核态和用户态均可访问(进程运行在用户态时, 产生线性地址范围)
			0xC0000000~0xFFFFFFFF	内核态访问(进程运行在内核态时, 产生线性地址范围)
			PAGE_OFFSET值为0xC0000000, 进程在线性地址中的偏移量, 内核空间开始
			页全局目录的第一部分页表项映射的线性地址小于PAGE_OFFSET(共1024项, PAE未启用时前768项, 启用后为前3项, 剩余的表项对所有进程相同)			
		内核页表
			1.对内核的数据结构进行管理
			2.页表部分作为参考模型
			临时页全局目录, 在内核编译过程中静态初始化, 由startup_32函数临时页表
			  临时页全局目录放在swapper_pg_dir变量中, 临时页表在pg0变量处开始存放, 紧接着在_end后
			内核代码段和数据段, 初始化页表和128KB内存范围能容纳于RAM前8MB, 需要用两个页表映射(2*1024*4K = 8MB(一个页表1024项))
			第一阶段
				允许在实模式和保护模式下都能容易访问8MB, 内核创建映射
				0x00000000~0x007FFFFF 通过与物理地址相同的线性地址进行访问
				0xC0000000~0xC07FFFFF --> 0x00000000~0x007FFFFF 通过0xC0000000~0xC07FFFFF线性地址进行访问