1.select函数有什么作用

int select(int maxfdp, fd_set* readfds, fd_set* writefds, fd_set* errorfds, struct timeval* timeout);
在编程的过程中，经常会遇到许多阻塞的函数，好像read和网络编程时使用的recv, 
recvfrom函数都是阻塞的函数，当函数不能成功执行的时候，程序就会一直阻塞在这里，
无法执行下面的代码。这是就需要用到非阻塞的编程方式，使用selcet函数就可以实现非阻塞编程。
selcet函数是一个轮循函数，即当循环询问文件节点，可设置超时时间，
超时时间到了就跳过代码继续往下执行。

select函数有5个参数
第一个是所有文件节点的最大值加1,如果我有三个文件节点1、4、6,那第一个参数就为7（6+1）
第二个是可读文件节点集，类型为fd_set。通过FD_ZERO(&readfd);初始化节点集；
然后通过FD_SET(fd, &readfd);把需要监听是否可读的节点加入节点集
第三个是可写文件节点集中，类型为fd_set。操作方法和第二个参数一样。
第四个参数是检查节点错误集。
第五个参数是超时参数，类型为struct timeval，然后可以设置超时时间，
分别可设置秒timeout.tv_sec和微秒timeout.tv_usec。
然后调用select函数，用FD_ISSET()函数判断节点是否可读写。
返回值不为0表示可读写，为0表示不可读写。select函数的返回值为是一个整数，
表示有几个节点可读写。


2.死锁，如何避免死锁
所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），
若无外力作用，这些进程都将无法向前推进。
在有些情况下死锁是可以避免的。三种用于避免死锁的技术：

Ⅰ加锁顺序（线程按照一定的顺序加锁）
当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。
如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

Ⅱ加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
叁、死锁检测

3.信号量对应的函数:

int semget(key_t key, int nsems, int semflg)
得到一个信号量集标识符或创建一个信号量集对象
key 0(IPC_PRIVATE)：会建立新信号量集对象
nsems创建信号量集中信号量的个数，该参数只在创建信号量集时有效
msgflg:IPC_CREAT：当semflg&IPC_CREAT为真时，如果内核中不存在键值与key相等的信号量集，
则新建一个信号量集；如果存在这样的信号量集，返回此信号量集的标识符
IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的信号量集，
则新建一个消息队列；如果存在这样的信号量集则报错

int semop(int semid, struct sembuf *sops, unsigned nsops)
完成对信号量的P操作或V操作
semid：信号量集标识符
sops：指向进行操作的信号量集结构体数组的首地址
nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。
最常见设置此值等于1，只完成对一个信号量的操作

int semctl(int semid, int semnum, int cmd, union semun arg)
得到一个信号量集标识符或创建一个信号量集对象
semid信号量集标识符
semnum信号量集数组上的下标，表示某一个信号量

4.TCP的三次握手
第一步：client 发送 syn 到server 发起握手；
第二步：server 收到 syn后回复syn+ack给client；
第三步：client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack
（此时client的56911端口的连接已经是established）。

5.TCP和UDP的区别
TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，
而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，
还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，
易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，
确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接
，事实上，每个连接都会占用系统的CPU、内存等硬件资源。而且，因为TCP有确认机制、三次握手机制，
这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，
UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，
UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，
比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，
在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，
那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，
比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，
比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。
 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，
用的FTP Outlook，用的POP、SMTP Putty，
用的Telnet、SSH QQ文件传输 ,什么时候应该使用UDP：
 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。
 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

TCP与UDP区别总结：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，
且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

6.TCP的建立以及对应的函数
服务器：
1、创建一个socket，用函数socket()；

2、设置socket属性，用函数setsockopt();
 * 可选
3、绑定IP地址、端口等信息到socket上，用函数bind();

4、开启监听，用函数listen()；

5、接收客户端上来的连接，用函数accept()；

6、收发数据，用函数send()和recv()，或者read()和write();

7、关闭网络连接，关闭监听的closesocket();
客户端：
1、创建一个socket，用函数socket()；

2、设置socket属性，用函数setsockopt();
* 可选
3、绑定IP地址、端口等信息到socket上，用函数bind();
* 可选
4、设置要连接的对方的IP地址和端口等属性；

5、连接服务器，用函数connect()；

6、收发数据，用函数send()和recv()，或者read()和write();


UDP编程的服务器端一般步骤是：

1、创建一个socket，用函数socket()；

2、设置socket属性，用函数setsockopt();
* 可选
3、绑定IP地址、端口等信息到socket上，用函数bind();

4、循环接收数据，用函数recvfrom();

5、关闭网络连接；

UDP编程的客户端一般步骤是：

1、创建一个socket，用函数socket()；

2、设置socket属性，用函数setsockopt();
* 可选
3、绑定IP地址、端口等信息到socket上，用函数bind();
* 可选
4、设置对方的IP地址和端口等属性;

5、发送数据，用函数sendto();

6、关闭网络连接；

7.多线程怎么退出，是在创建的子进程内退出还是在主程序里面退出

8.网络字节序：htons将主机的无符号短整形数转换成网络字节顺序
NBO 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。

9.TCP的报文格式
标识进程
源端口（Source port）和目的端口（Destination port）
各16 bits。IP地址标识互联网中的不同终端，端口号标识终端中的不同应用进程，具有本地意义。
32位IP + 16位端口号 = 48位插口。
 
端口由互联网数字分配机构（Internet Assigned Numbers Authority，IANA）分配，
TCP和UDP端口号列表。

- 序号（Sequence Number）和确认序号（Acknowledgment Number）

各32 bits。
TCP连接传输的字节流中的每一个字节都有序号。SN指示本报文段所发送的数据第一个字节的序号。
AN指示期望收到对方的下一个报文的第一个字节的序号，所有小于AN的报文都被正确接收。

首部长度（Data offset）
4 bits，以32-bit字为单位。TCP首部长短，也是TCP报文数据部分的偏移量。
范围5~15，即20 bytes ~ 60 bytes。options部分最多允许40 bytes。

保留（Resevered）
3 bits，将来使用，目前应设为0。

标志位（Flags）
URG = 1，指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。
 
PSH = 1，接到后尽快交付给接收的应用进程。
 
RST = 1，TCP连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。
 
FIN = 1，发送端已完成数据传输，请求释放连接。
 
SYN = 1，处于TCP连接建立过程。 

 ACK = 1，确认序号（AN）有效。

窗口（Window size）
16 bits，接收窗口的大小。接收端希望接收的字节数。



校验和（Checksum）
16 bits，校验报文首部、数据。

紧急指针（Urgent pointer）
16 bits，
如果URG = 1，该字段指示紧急数据的大小（相对于SN的偏移），紧急数据在数据部分的最前面。



可选项（Options）
TCP报文的字段实现了TCP的功能，

标识进程、对字节流拆分组装、差错控制、流量控制、建立和释放连接等。

10.PayLoad里面放了些什么

11.什么叫流式传输，什么是报文传输
现在主要指通过网络传送流媒体（如视频、音频）的技术总称。
其特定含义为通过Internet 将影视节目传送到PC机。
实现流式传输有两种方法：实时流式传输（Realtime streaming）和顺序流式传输（progressive streaming）

报文=数据块

12.UDP为什么是无链接的
udp每个客户端端口，并不需要跟服务器端口建立长期的连接，可以每次向一个服务器端口发起申请，
然后下一次再向另外一个服务器端口申请接收数据，
这样，一个udp服务器接口可以一段时间内接受多个客户端发送的请求，
一个客户端接口也可以短时间内接收多个服务端发来的数据。

13.线程和进程的区别

1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）

2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，
建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，
使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，
同时创建一个线程的开销也比进程要小很多。

3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，
而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，
而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

14.进程通信（InterProcess communication）
一、管道int pipe（int fd[2]）
1.它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
2.只能用于具有亲缘关系的进程之间的通信
3.它可以看成是一个特殊文件，对于它的读写也可以使用普通的read,write等函数。
但它不是普通的文件，并不属于其他任何文件系统，并且只存在与内存中。

二、FIFO也称为命名管道int mkfifo(const char *pathname,mode_t mode);
特点1.FIFO可以在无关的进程之间交换数据，与无名管道不同。
       2.FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

三、消息队列
是消息的链接表，存放在内核中，一个消息队列由一个标识符（即队列ID）来标识
其中的消息具有特定的格式以及特定的优先级。
特点：1.消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
2.消息队列独立于发送与接受进程。进程终止时，消息队列及其内容并不会被删除。
3.消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取
#include <sys/msg.h>
int msgget(key_t key,int flag);创建或打开消息队列：成功返回队列ID，失败返回-1
int msgsnd(int msgid, const void *ptr,size_t size,int flag);添加消息，成功返回0，失败返回-1
int msgrcv(int msgid, void *ptr,size_t size,long type,int flag);读取消息：成功返回消息的长度，-1
int msgctl(int msgid,int cmd,struct msgid_ds *buf);控制消息队列，成功返回0，失败返回-1

四，信号量
他是一个计数器，信号量用于试先进程间的互斥与同步，而不是用于存储进程间通信数据。

1.信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
2.信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。
3.每次对信号量PV操作 不仅限于对信号量值加1或减1，而且可以加减任意正整数。
4.支持信号量组。
#include <sys/sem.h>
int semget(key_t,int num_sems,int sem_flags);//创建或获取一个信号量组，若成功返回信号量集ID-1
itn semop(int semid,struct sembuf semoparray[],size_t numops);对信号量组进行操作，改变信号量值
int semctl(int semid ,int sem_num,int cmd,.....);//控制信号量相关信息。

五、共享内存
指两个或多个进程共享一个给定的存储区。
特点：1.共享内存是最快的一种IPC,因为进程是直接对内存进行存取的。
          2.因为多个进程可以同时操作，所以需要进行同步。
          3.信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

1 #include <sys/shm.h>
2 // 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
3 int shmget(key_t key, size_t size, int flag);
4 // 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
5 void *shmat(int shm_id, const void *addr, int flag);
6 // 断开与共享内存的连接：成功返回0，失败返回-1
7 int shmdt(void *addr); 
8 // 控制共享内存的相关信息：成功返回0，失败返回-1
9 int shmctl(int shm_id, int cmd, struct shmid_ds *buf);

15.临界区是什么
 每个进程中访问临界资源的那段代码称为临界区（criticalsection），
每次只允许一个进程进入临界区，进入后，不允许其他进程进入。
不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。

临界资源
临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，
实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；
软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。

16.GDB调试
启动程序准备调试
GDB yourpram
或者
先输入GDB
然后输入 file yourpram
然后使用run或者r命令开始程序的执行,也可以使用 run parameter将参数传递给该程序

gcc -g -o e e.c
调试gdb e
或者输入gdb
然后 file e
run 
list l 显示多行源代码
break b 设置断点,程序运行到断点的位置会停下来 delete breakpoints 断点号
info i 描述程序的状态
run r 开始运行程序
display disp 跟踪查看某个变量,每次停下来都显示它的值
step s 执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next n 执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
watch  监视变量值的变化
continue c 继续程序的运行，知道遇到下一个断点。
set var i=8  设置变量的值
print p 打印内部变量值
quit q 退出GDB环境

17.Shell编程
shell编程就是对一堆Linux命令的逻辑化处理。
#!/bin/bash
#第一个shell小程序
echo hello world!

#!/bin/bash
path=$(pwd)
files=`ls -al`
echo current path: $path
echo files: $files

18.C语言的编译过程：预处理、编译、汇编、连接
预处理  展开头文件/宏替换/去掉注释/条件编译  test.i main.i 
宏优点1代码复用性2提高性能
宏缺点1 不可调试（预编译阶段进行了替换），2无类型安全检查3可读性差，容易出错
编译     检查语法，生成汇编    test.s main.s
汇编     汇编代码转换成机器码   test.o main.o 
链接     链接到一起生成可执行文件    a.out
将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件

19.C语言的内存是如何排布的
BSS段（Block Started by symbol） 通常是指用来存放程序中未初始化的全局变量的一块内存区域
BSS段属于静态内存分配。

数据段 通常是指用来存放程序中已初始化的全局变量的一块内存区域，
数据段属于静态内存分配

代码段 通常是指用来存放程序执行代码的一块内存区域。
这部分区域的代码属于只读。在代码段中，字符串常量也属于这部分。

堆 堆是用来存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

栈 栈又称堆栈，存放程序的局部变量，在函数被调用时，栈用来传递参数和返回值等。
由于栈的先进后出，特别方便用来保存和回复调用现场。
0xffffffff内核地址空间
0xc0000000
命令行参数，环境变量
栈


堆
未初始化数据段.bss      由exec加载后，初始化为0
已初始化数据段.data .rodata    由exec从程序文件中加载
代码段.text    由exec从程序文件中加载
未使用

20.fwrite和write的区别
fwrite时通过write来实现的，fwite是C语言的库，而write是系统调用。
差别在于，write每次写的数据都是调用者要求的大小，比如调用者要求写入10个字节数据，write
就会写10个数据到内核缓冲区中，所以依然涉及到用户态与内核态之间的切换，操作系统会定期地把
这些存在内核缓冲区的数据写回磁盘中。而fwrite不一样，fwrite每次都会把数据写入一个应用进程
缓冲区，等到该缓冲区满了，或者调用类似调用fflush这种冲洗缓冲区的函数时，系统会调用write一次性
把相应数据写进内核缓冲区中，同样减少了系统调用（即write调用）

21.strstr是干嘛的：strstr(str1, str2)函数用于判断字符串str2是否是str1的子串
如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。

22.指针
指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。
int p; //这是一个普通的整型变量  
int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,
说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针  
int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,
说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组  
int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,
然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,
说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组  
int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,
只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,
说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针  
int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,
说明指针所指向的元素是指针,然后再与int 结合,
说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,
所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.  
int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,
说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据  
Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,
然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,
说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针  
int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,
说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,
说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,
然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.
所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 

23.结构体拷贝问题
浅拷贝只拷贝指针变量的值，不需要分配释放空间。
深拷贝则需要分配空间释放空间。


typedef struct Tea{

    char name[64];
    
    int age;
    
    char *aliname;

}Tea;
 

void Copyteacher(Tea *from,Tea *to)

{
    
    //浅拷贝(结构体中嵌套一个一级指针或者二级指针)
    
    //编译器的 = 操作只会把 from 的指针变量的值拷贝到 to 空间去

    //*to = *from;

    memcpy(to,from,sizeof(Tea));

}


void Copyteacher(Tea *from,Tea *to)

{
    
    //浅拷贝(结构体中嵌套一个一级指针或者二级指针)

    //编译器的 = 操作只会把 from 的指针变量的值拷贝到 to 空间去

    //*to = *from;
    //memcpy(to,from,sizeof(Tea));

 
    //深拷贝（想要深拷贝就显式的分配内存然后释放内存）

    *to = *from;

    to->aliname = (char*)malloc(100);

    strcpy(to->aliname,from->aliname);

}


24.字符串常用操作函数
strlen();用于统计字符串长度
一、strlen()是一个函数，sizeof是一个运算符，这是本质上的区别
二、strlen()测量的是字符的实际长度，以'\0'结束；如果只定义没有给他赋值，这个结果是不定的，
它会从首地址一直找下去，直到遇到'\0'为止。sizeof返回的是变量定义 后所占内存的字节数，
不是实际长度
三、sizeof可以用类型作为参数，而strlen只能用char *作为参数，而且是必须以'\0'结尾的。

strcat();用于拼接两个字符串；
函数接受两个字符串为参数。该函数把第二个字符串的备份附加到第一个字符串的末尾，并把拼接后
的新字符串作为第一个字符串，第二个字符串不改变。strcat函数的类型是char *
char *strcat(char *s1,char *s2)
{
    char *p;
    p=(char *)malloc((strlen(s1)+strlen(s2)+1)*sizeof(char *));
    strcpy(p,s1);
    strcpy(p+strlen(s1),s2);
    p[strlen(s1)+strlen(s2)+1]='\0';
    return p;
}

strcmp();用于比较两个字符串是否相同。
strcmp返回值；若两个参数相同，返回“0”；若参数1大于参数二，返回一个正整数，相反返回负整数

sprintf();把数据写到字符串中，该函数可把多个元素组合成一个字符串，sprintf的第一个参数是目标
字符串的地址，

void * memset( void * ptr, int value, size_t num ); 
memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组
memset(str, ‘\0’, sizeof(str)-1); 
void bzero(void *s, int n);
bzero()会将参数s 所指的内存区域前n 个字节，全部设为零值。

25.栈里面都放了什么东西。
栈：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。
里面的变量通常是局部变量、函数参数等。
堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，
一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
全局存储区（静态存储区）：全局变量和静态变量的存储是放在一块的，
初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区
域。程序结束后有系统释放。
常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

26.字符串反转
int inverse_stack(char *str1)
{
    if(str1 == NULL)
    {
        retrun 0;
    }
    if(*str1 == '\0')
    {
        return 0;
    }
    inverse_stack(str+1);
    printf("%c",*str1);
}

int inverse(char *str)
{
    int length = 0;
    char *p1 = NULL;
    char *p2 = NULL;
    if(str == NULL)
    {
        return -1;
    }
    
    length = strlen(str);
    p1 = str;
    p2 = str+(length-1);
    
    while(p1 < p2)
    {
        char c = *p1;
        *p1 = *p2;
        *p2 = c;
        ++p1;
        --p2; 
    }
    return 0;
}

27.判断链表有环

boolen hascycle(node head)
{
    if(head->next == null)  
    {
        return false;
    }
    node fastnode = head;
    node slownode = head;
    while(fastnode != null)
    {
        if(fastnode->next!=null)
        {
            fastnode = fastnode->next->next;
        }
        else
        {
            fastnode = null;
        }
        slownode = slownode -> next;
        if(slownode == fastnode)
        {
            return true;
        }
    }
    return false;
}


28.静态链接和动态链接的区别
一、动态库总是与应用程序编译在一起的，在任何情况下都能运行，不依赖外部的情况，而动态库是
动态链接的，就是在程序真正运行的时候才会链接，所以当用户的系统上没有该动态库的时候，
应用程序就会运行失败。
二、多个程序可以共享一个动态库，当启动多个使用相同动态库的应用程序时，只需要将动态库加载到
内存一次就OK了，相反，对于使用静态链接的应用程序都比较大，如果多个应用程序使用相同的静态
库，我们依然需要多次装载到内存中，浪费内存。
三、静态链接的应用程序一般执行速度比较快，应为所有需要的代码都已经放在可执行文件中了，
而动态连接的应用程序却需要在运行过程中动态调用动态库，因此速度也略慢
四、对于静态链接的应用程序，如果静态库发生了变化，那么整个程序都会需要重新编译。而动态连接
的应用程序就没这个问题了，在动态接口不变的情况下，我们升级动态库不影响我们的应用程序。

29.中断模型



30.设备模型
linux提供了新的设备模型：总线（bus）,设备(device),驱动(driver)，
总线是处理器与设备之间的通道，在设备模型中，所有的设备都是通过总线相连。
设备是对于一个设备的详细信息描述。
驱动是设备的相关驱动。
bus相当一个容器，是device和device_driver的管理机构，它包含了一个device集合和一个driver集合。

31.proc文件系统
/proc文件系统是一个虚拟文件系统，通过它可以在linux内核系统和用户之间进行通信。


32.
-c 只激活预处理，编译和汇编，最终生成.o文件
-S只激活预处理和编译，就是把文件编译成汇编代码.s文件
-E只激活预处理，不生成文档，需要把他重新定向到一个输出文档里。
gcc -E hello.c > pianoapan.txt
一个hello word 也要预处理成800行的代码
-o定制目标名称，缺省的时候gcc编译出来的文档是a.out
-ansi关闭gnu c中的ansi c不兼容的特性，激活ansi c的专有特性。
-share此选项将尽量使用动态库，所以生成文档比较小，但是需要系统有动态库。
-Wall(warning all)显示所有警告信息
-include file包含某个代码，相当于在代码中使用#include 
gcc hello.c -include /root/hello.h
-O0 -O1 -O2 -O3编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省，-O3优化级别最高
volatile的作用是作为指令关键字，确保指令不会因编译器的优化而省略，要求每次直接读值。
精确的说，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器
里的备份。

33.makefile
    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
    2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
    3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，
    并链接目标程序。
一、输入make命令后会在当前目录下找“makefile”的文件
二、如果找到，它会找文件中第一个目标文件（target），并把这个文件作为最终的目标文件。main
三、如果main文件不存在，或者是main所依赖的后面的.o文件修改时间比main这个文件新，那么
它就会执行编译命令来生成main
四、如果
edit : main.o display.o /
    insert.o
    cc -o edit main.o diaplay.o /
    insert.o

main.o : main.c defs.h
    cc -c main.c

display.o : diaplay.c defs.h buffer.h
    cc -c diaplay.c
clean :
    rm edit mian.o display.o /
    insert.o
    

34.驱动想要被外部看到应该怎么样:export
EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL(name);
这两个宏军用与将给定的符号导出到模块外，GPL版本的宏定义只能使符号对GPL许可的模块可用
符号必须在模块文件的全局部分导出，不能在函数中导出，这是因为上诉这两个宏将被扩展成一个
特殊用途的声明，而该变量必须是全局的。
#define EXPORT_SYMBOL(sym)  \
    __EXPORT_SYMBOL(sym,"");

#define EXPORT_SYMBOL_GPL(sym)  \
    __EXPORT_SYMBOL(sym,"_gpl");

35.如何安装驱动程序
1.用户界面 ：Ubantu提供了一个附加驱动程序选项。
2.命令行：通过yum,dnf,apt-get等下载获取。 
    或者通过wget命令下载源码包，然后运行配置和编译安装
add-apt-repository 是由 python-software-properties 这个工具包提供的
sudo add-apt-repository  PEPOLIST_OF_DRIVER 将仓库加入到仓库列表中
sudo apt-get update 更新仓库列表
sudo apt-get install NAME_OF_DRIVER
检查是否已经安装了这个驱动程序：
$ lspci  显示系统上所有PCI总线和设备驱动程序的详细信息
$ dmesg 显示了所有内核识别的驱动程序

36.RTSP的端口
Real Time Streaming Protocol 实时流传输协议
端口：HTTP 80/RTSP 554/HTTPS 110(443)/onvif端口 80
RTSP地址：rtsp://用户名:密码@ip:端口号/video123 123对应3个码流


37.HI3518EV200支持的最大分辨率
海思HI3518EV200  wifi摄像头 720p（1280*720分辨率）

38.uboot是如何引导内核的


39.uboot是怎么给内核传参的



40.nfs服务器用来干嘛
nfs通过rpcbind这个服务去跟客户段通信的。NFS网络文件系统一般被用来存储共享视频，图片，附件等
资源，NFS是当前互联网系统架构中最常用的数据存储服务之一。

41.busybox
BusyBox是一个继承了300多个最常用Linux命令和工具的软件。BusyBox包含了一些简单的工具，
例如ls、cat和echo等。grep find rm等

42.如何调试程序

43.快速排序
void quicksort(int left,int right)
{
    int i,j,t,temp;
    if(left>right)
    {
        return ;
    }
    temp = a[left];
    i=left;
    j=right;
    while(i != j)
    {
        while(a[j] >= temp && i < j )
        {
            j--;    
        }
        while(a[i] <= temp && i < j)
        {
            i++;
        }
        if(i < j)
        {
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    a[left] = a[i];
    a[i] = temp;
    quicksort(left,i-1);
    quicksort(i+1,right);
}

44.如何用UDP实现安全传输
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，
只是实现不再传输层，转移到了应用层。
实现确认机制、重传机制、窗口确认机制。

添加seq/ack机制，确保数据发送到了对端。
添加发送和接受缓冲区，主要是用户超时重传。
添加超时重传机制
（
一、当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。
如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，
它将发送一个确认。TCP有延迟确认的功能，在此功能没有打开，则是立即确认。
功能打开，则由定时器触发确认时间点。
二、TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。
TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。
这将防止较快主机致使较慢主机的缓冲区溢出。
）
目前有如下开源程序利用UDP实现了可靠的数据传输。RUDP,RTP,UDT


45.众多客户端，如何在服务端判断哪个客户端是否关闭，如果是光机，又是如何判断的
可以根据服务器收到的数据的长度来判断，如果服务器收到的数据长度为0，那么意味着你的客户端程序
已经断开了连接。
当使用 select()函数测试一个socket是否可读时，如果select()函数返回值为1，
且使用recv()函数读取的数据长度为0 时，就说明该socket已经断开。

46.typedef 和#define的区别
#define是预处理命令，在编译预处理时进行简单的替换，不做正确性检查，不关含义是否正确照样带入
只有在编译时已被展开的源程序时才会发现可能的错误
typedef时在编译时处理的，它在自己的作用域内给一个已经存在的类型一个别名

47.编译”前，计算机做了什么。“编译后”，计算机得到了什么



48.struct和union的区别
在存储多个成员信息时，编译器会自动给struct成员分配储存空间，struct可以储存多个成员信息，
而union每个成员都会用同一个储存空间，只能储存最后一个成员的信息。
都是由多个不同的数据成员著称，但在任何同一时刻，union只存放来了一个被选中的成员，而结构
体的所有成员都存在。
对于union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对struct的不同成员
赋值，是互不影响的。


49.怎么引用数组元素，可以*p[i]吗？
非法的间接寻址，*p[i]的意思是调用一个名为p的指针数组的物理内存顺序上的第i+1个元素并取他
所指向的对象。


50.动态分配的内存，局部变量，静态变量分别存放在哪里
局部变量：分配的内存在栈里，stack的空间由操作系统自动分配和释放。
全部变量：放在静态存储区，
动态分配：数据存在内存的堆里面，

51.linux中栈分配大小默认是多少
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <unistd.h>
 
int main()
{
    struct rlimit lmt;
 
    getrlimit(RLIMIT_STACK,&lmt);
 
    printf("rlim_cur=%u,rlim_max=%u\n",lmt.rlim_cur,lmt.rlim_max);
}
堆栈空间为8M,但作为拓展，最大可支持4G

52.什么是红黑树
红黑树（Red Black Tree） 是一种自平衡二叉查找树，
是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，
对于任何有效的红黑树我们增加了如下的额外要求
性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
每个叶子的节点都是黑色的空节点

53.数据结构，二叉树
二叉树具有五种基本形态：
1.空二叉树
2.只有一个根节点
3.根节点只有左子树
4.根节点只有右子树
5.根节点既有左子树又有右子树
完全二叉树的特征：


1.叶子结点只能出现在最下两层


2.最下层的叶子一定集中在左部连续位置


3.倒数二层，若有叶子结点，一定都在右部连续位置


4.如果节点度为1（这里的度与离散数学中的度不一样，这里的度是指节点所拥有的子树数），
则该节点只有左孩子，即不存在只有右子树的情况

5.同样节点数的二叉树，完全二叉树的深度最小

54.TCP如何检测包错误
一、奇偶校验
根据被传输的一组二进制代码中“1”的个数是奇数或偶数来进行校验。
二、CRC校验（循环冗余校验码）
CRC校验是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。
循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，
并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。
三、LRC校验
LRC校验用于ModBus协定的ASCII模式，这各校验比较简单，通讯速率较慢，
它在ASCII协议中使用，检测了消息域中除开始的冒号及结束的回车换行号外的内容。
它仅仅是把每一个需要传输的数据字节迭加后取反加1即可。

55.线程资源要不要回收
Linux系统中程序的线程资源是有限的，表现为对于一个程序其能同时运行的线程数是有限的。
而默认的条件下，一个线程结束后，其对应的资源不会被释放，于是，如果在一个程序中，
反复建立线程，而线程又默认的退出，则最终线程资源耗尽，进程将不再能建立新的线程。
一、由系统自动释放
如果想在线程结束时，由系统释放线程资源，则需要设置线程属性为detach，是线程分离主线程
pthread_attr_setdetachstate(&a, PTHREAD_CREATE_DETACHED);      //设置线程属性
二、由另一个线程将该资源释放
pthread_join（t）;等待线程t退出，并释放t线程所占用的资源；
函数会堵塞等待指定线程退出，然后回收资源，这样就有同步的功能，使一个线程
等待另一个线程退出，然后才继续运行，

56.线程同步的作用
线程同步：多个线程同时访问同一资源，等待资源访问结束，浪费时间，效率低
多进程或者多线程访问临界资源时，必须进行同步控制。多进程或者多线程的
执行并不完全是绝对的并行运行，有可能主线程需要等待函数线程的某些条件的发生。

57.ip协议和icmp协议分别在哪一层
IP协议对应于OSI标准模型的网络层
TCP/IP:
数据链路层：ARP,RARP
网络层： IP,ICMP,IGMP
传输层：TCP ,UDP,UGP
应用层：Telnet,FTP,SMTP,SNMP.
OSI:
物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS
数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2
网络层：IP，IPX，AppleTalk DDP
传输层：TCP，UDP，SPX
会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP
表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML
应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP

58.linux的权限管理
-rw-r--r--
  - 第一个"-"表示文件类型(- 文件，d 目录，l 软链接文件)
  - rw-       r--       r--
    u所有者   g所属组   o其它人
其中r读，w写，x执行 可进入目录
chmod 基本权限修改
chown修改文件的所有者
chgrp修改文件的所属组 chgrp 组名 文件名
unmak查看默认权限
临时修改： umask 0022 
- 第一位0: 文件特殊权限
  - 022 : 文件默认权限
永久修改： vi  /etc/profile


59.共享内存
int shmget(key_t key,size_t size,int shmflg);
创建共享内存，key 为共享内存的大小，size共享内存的大小。

void *shmat(int shmid,const void *shmaddr,int shmflg);
int shmdt(const void *shmaddr);
功能：将共享内存块连接到进程地址空间；
参数：shmid共享内存标识符，shmaddr一般取值为NULL，shmflg一般取值为0；
返回值：成功返回一个指针；失败返回一个-1；

特点：
（1）共享内存是最快的IPC形式，因为一旦共享内存创建成功，就会由页表映射到进程地址空间，进程间
的数据不需要传递到内核。
（2）共享内存没有同步与互斥机制，在使用时需要自己维护代码。
（3）共享内存的生命周期随内核。

60.信号量
(1)信号量本质上时计数器，是衡量临界资源的数量的；
(2)信号量也是一种临界资源，他的作用是保护临界资源；
(3)信号量只有两种操作，PV，P表示申请资源，V表示释放资源；


61.文件描述符
内核利用文件描述符来访问文件。文件描述符是非负整数。打开现存文件或新建文件时。内核会返回一个
文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。
实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。












